<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_EL7201_AXIS_CTRL" Id="{fa4d0faa-67b6-4e72-aafa-c53e3596d68e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_EL7201_AXIS_CTRL
(*************************************************************************************************)
(*  FILENAME:    FB_EL7201_AXIS_CTRL.EXP                                                         *)
(*  PROJECT:     CALMAR PUPLC                                                                    *)
(*  COPYRIGHT:   All rights reserved (c) Wifag//Polytype, Fribourg/Switzerland (2016)            *)
(*  ENVIRONMENT: TwinCAT PLC                                                                     *)
(*  VERSION:     <version>                                                                       *)
(*************************************************************************************************)
(*  DESCRIPTION:                                                                   <description> *)
(*     This function transfers the movement commands to the motor.                               *)
(*     It also controls the states of the EL7201 for the Cleaning Unit.                          *)
(*                                                                                </description> *)
(*************************************************************************************************)

{library public}
VAR_INPUT
  fI_TargetPosition              : REAL;                         (*Target position*)
  fI_Tolerance                   : REAL := 0.0001;               (*Position tolerance*)
  fI_SpeedLimit                  : REAL;                         (*Speed limit*)
  bI_MoveEnable                  : BOOL;                         (*Enable movement*)
  bI_RegActive                   : BOOL;                         (*Regulation active*)
  bI_FaultReset                  : BOOL;                         (*Fault reset*)
  bI_MsgReset                    : BOOL;                         (*Message reset*)
  bI_EStop                       : BOOL;                         (*Emergency stop*)
  bI_SetPosition                 : BOOL;                         (*Set position*)

  wI_StatusWord                  : UINT;                         (*Status word: 6041:0*)
  lI_EncoderValue                : DINT;                         (*Encoder value*)
  fI_PosControllerGain           : REAL := 1.0;                  (*Position controller gain*)
  fI_EncoderScaling              : REAL := 1048576;              (*Encoder scaling [counts/rev]*)
  fI_Axis_Scaling                : REAL := 0.0002;               (*Axis scaling [m/rev]*)
  fI_SetPositionValue            : REAL := 0.0;                  (*Set position value [m]*)
  fI_SpeedScaling                : REAL := 268435;               (*Speed scaling [counts/rev]*)

  pI_OffsetEncoder               : POINTER TO DINT;              (*Offset to remanent value in encoder*)

  fI_TolDriveTimeFactor          : REAL := 2.0;                  (*Factor for tolerated drive time*)
END_VAR

VAR_OUTPUT
  wO_ControlWord                 : UINT;                         (*Control word:  6040:0*)
  iO_TargetVelocity              : DINT;                         (*Target velocity:  60FF:0*)
  fO_ActualPosition              : REAL;                         (*Actual position [m]*)
  bO_MoveOk                      : BOOL;                         (*Movement ok*)
  eO_EL7201Status                : EN_EL7201_STATE;              (*EL7201 status*)
  bO_WarnDriveTime               : BOOL;                         (*Error drive time too long*)
END_VAR

{library private}
VAR
  fL_Delta_P                     : REAL;                         (*Delta position*)
  fL_CommandSignal               : REAL;                         (*Command signal*)

  tL_TimerRampUP                 : TON;                          (*Timer ramp up*)
  fL_PercentageRampUP            : REAL;                         (*Percentage ramp up*)
  tL_TimerRampDN                 : TON;                          (*Timer ramp down*)
  fL_PercentageRampDN            : REAL;                         (*Percentage ramp down*)

  wL_MaskedStatusWord            : WORD;                         (*Masked status word*)
  bL_memMoveEnable               : BOOL;                         (*Memory enable movement*)
  bL_memSetPosition              : BOOL;                         (*Memory set position*)
  fL_memTargetPosition           : REAL := 0.0;                  (*Memory target position*)
  bL_StopRamp                    : BOOL;                         (*Stop ramp*)
  bL_FirstRun                    : BOOL := TRUE;                 (*First run*)

  fL_Divider                     : REAL;                         (*Divider for percent calculation*)
  
  fb_RTrigEnable                 : R_TRIG;                       (*RTrig for motor enable*)
  fL_CalcDriveTime               : REAL;                         (*Calculated drive time [s]*)
  fL_RampDriveTime               : REAL := 10;                   (*Ramp time [s]*)
  tL_DriveTime                   : TON;                          (*Timer drive time*)
  iL_SpeedNotSetCounter          : UINT;                         (*Debug: speed limit for calculation not set*)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Input();

tL_TimerRampUP.PT :=T#300ms;
tL_TimerRampUP();

tL_TimerRampDN.PT :=T#300ms;
tL_TimerRampDN();

IF bI_MoveEnable=FALSE AND bL_memMoveEnable=TRUE THEN
	bL_StopRamp := TRUE;
END_IF;

IF bI_MoveEnable=TRUE AND bL_memMoveEnable=FALSE THEN
	fL_memTargetPosition := fI_TargetPosition;
	bO_MoveOK := FALSE;
ELSIF bL_FirstRun THEN
	fL_memTargetPosition := fO_ActualPosition;
END_IF;


IF tL_TimerRampDN.Q THEN
	bL_StopRamp:=FALSE;
END_IF;

tL_TimerRampDN.IN := bL_StopRamp;

fL_Divider := TIME_TO_REAL(tL_TimerRampDN.PT);
IF fL_Divider <> 0 THEN
	fL_PercentageRampDN := TIME_TO_REAL(tL_TimerRampDN.ET)/fL_Divider;
END_IF;

tL_TimerRampUP.IN := bI_MoveEnable AND bI_RegActive;

fL_Divider := TIME_TO_REAL(tL_TimerRampUP.PT);
IF fL_Divider <> 0 THEN
	fL_PercentageRampUP := TIME_TO_REAL(tL_TimerRampUP.ET)/fL_Divider;
END_IF;

(* ---------------------- Calculation of the Error Signal between the Target and the Actual Position -----------------*)
fL_Delta_P := fI_TargetPosition - fO_ActualPosition;

(* --------------------------------- Calculation of the Command Signal for the Target Velocity  ---------------------------*)
fL_CommandSignal := fL_Delta_P * fI_PosControllerGain;

(* ----------------------------- Limitation of the Command Signal between +/- SpeedLimit --------------------------------*)
IF fL_CommandSignal > (fI_SpeedLimit) THEN
	fL_CommandSignal:= fI_SpeedLimit;
ELSIF fL_CommandSignal < (-fI_SpeedLimit) THEN
	fL_CommandSignal:=-fI_SpeedLimit;
END_IF;

IF bI_MoveEnable THEN
	IF fI_Axis_Scaling <> 0 THEN
		iO_TargetVelocity:= FC_REAL_TO_DINT((fI_SpeedScaling / fI_Axis_Scaling * fL_CommandSignal * fL_PercentageRampUP));			(* Send the Target velocity command to module *)
	END_IF;
ELSE
	IF fI_Axis_Scaling <> 0 THEN
		iO_TargetVelocity:= FC_REAL_TO_DINT((fI_SpeedScaling / fI_Axis_Scaling * fL_CommandSignal * (1-fL_PercentageRampDN)));	(* Send the Target velocity command to module *)
	END_IF;
END_IF;
(* ---------------------- MDP StateMachine ----------------- *)

wL_MaskedStatusWord := UINT_TO_WORD(wI_StatusWord) AND 16#006F;

IF bI_EStop=FALSE THEN
	iO_TargetVelocity:=0;
	eO_EL7201Status := eEstopped;
	wO_ControlWord := 16#0000;
	wO_ControlWord := 16#0002;
ELSE

	CASE wL_MaskedStatusWord OF
			16#0000, 16#0020:								(* ------------------ State : Not Ready to Switch On : x0xx0000 ---------------------- *)
				eO_EL7201Status := eNotReadyToSwitchON ;

			16#0040, 16#0060:								(* ------------------ State : Switch ON Disable : x1xx0000 ---------------------- *)
				eO_EL7201Status := eSwitchONDisabled ;
				wO_ControlWord := 16#0006;

			16#0021:										(* ------------------ State : Ready To Switch ON : x01x0001---------------------- *)
				eO_EL7201Status := eReadyToSwitchON ;
				IF bI_RegActive=TRUE THEN
					wO_ControlWord := 16#0007;
				END_IF;

			16#0023:										(* ---------------- State : Switched ON : x01x0011------------------ *)
				eO_EL7201Status := eSwitchedON ;
				IF bI_MoveEnable=TRUE THEN
					wO_ControlWord := 16#000F;
				END_IF;

				IF bI_RegActive=FALSE THEN
					wO_ControlWord := 16#0006;
				END_IF;

			16#0027:										(* -------------- State : Enabled : x01x0111------------------ *)
				eO_EL7201Status := eEnabled;
				IF (bI_MoveEnable=FALSE AND tL_TimerRampDN.Q) THEN
					wO_ControlWord := 16#0007;
				END_IF;

			16#000F, 16#002F:								(* -------------- State : Fault Reaction Active : x0xx1111----------------- *)
				eO_EL7201Status := eFaultReactionActive ;

			16#0008, 16#0028, 16#0068:								(* --------------- State :  Fault : x0xx1000 ------------------- *)
				eO_EL7201Status := eFault;
				IF bI_FaultReset THEN
					wO_ControlWord := 16#0080;
				ELSE
					wO_ControlWord := 16#0000;
				END_IF;
	END_CASE;
END_IF;

(* ---------------------- Encoder Offset Calibration ----------------- *)

IF bI_SetPosition AND NOT bL_memSetPosition AND NOT bI_MoveEnable THEN
	IF fI_Axis_Scaling <> 0 THEN
		pI_OffsetEncoder^ := FC_REAL_TO_DINT((fI_SetPositionValue * fI_EncoderScaling / fI_Axis_Scaling - DINT_TO_REAL(lI_EncoderValue)));
	END_IF;

	fL_memTargetPosition := fO_ActualPosition;
END_IF;

(* ---------------------- Memory ----------------- *)
bL_memSetPosition := bI_SetPosition;
bL_memMoveEnable  := bI_MoveEnable;
bL_FirstRun       := FALSE;

(* ---------------------- Check motor for stiffness or blocking ----------------- *)
fb_RTrigEnable(CLK := bI_MoveEnable);
IF fb_RTrigEnable.Q THEN
  IF (fI_SpeedLimit <> 0) THEN
    fL_CalcDriveTime := ABS(fL_Delta_P / fI_SpeedLimit);
  ELSE
    fL_CalcDriveTime := 250;  (*SpeedLimit not set in time*)
    iL_SpeedNotSetCounter := iL_SpeedNotSetCounter + 1;
  END_IF

  tL_DriveTime(IN := TRUE, PT := REAL_TO_TIME(((fL_CalcDriveTime * fI_TolDriveTimeFactor) + fL_RampDriveTime) * 1000));
END_IF

IF bI_MoveEnable THEN
  tL_DriveTime();
ELSE
  tL_DriveTime(IN := FALSE);
END_IF

IF tL_DriveTime.Q THEN
  bO_WarnDriveTime := TRUE;
END_IF
IF bI_MsgReset THEN
  bO_WarnDriveTime := FALSE;
END_IF;


(********************************* END OF FB *****************************************************)]]></ST>
    </Implementation>
    <Action Name="Input" Id="{f7373bbf-8c2d-4e4a-b025-ea85b319d584}">
      <Implementation>
        <ST><![CDATA[(*EL7201 Standard: 20 Singleturn bits and 12 Multiturn bits*)
IF (fI_EncoderScaling <> 0) AND (pI_OffsetEncoder <> 0) THEN
	fO_ActualPosition := (DINT_TO_REAL(lI_EncoderValue) + DINT_TO_REAL(pI_OffsetEncoder^)) * fI_Axis_Scaling / fI_EncoderScaling;
END_IF;

(*Movement done?*)
IF bI_MoveEnable THEN
	IF ABS(fL_memTargetPosition - fO_ActualPosition) < fI_Tolerance*0.2 THEN
		bO_MoveOK := TRUE;
	ELSE
		bO_MoveOK := FALSE;
	END_IF;
ELSE
	IF ABS(fL_memTargetPosition - fO_ActualPosition) < fI_Tolerance THEN
		bO_MoveOK := TRUE;
	ELSE
		bO_MoveOK := FALSE;
	END_IF;
END_IF;

(********************************* END OF ACTION *************************************************)]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_EL7201_AXIS_CTRL">
      <LineId Id="363" Count="128" />
      <LineId Id="588" Count="24" />
      <LineId Id="512" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_EL7201_AXIS_CTRL.Input">
      <LineId Id="2" Count="19" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.3">
  <POU Name="FB_LineCamera" Id="{e6d6755d-f9bc-4501-9145-ca5769d0ea2d}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  QualiVision line camera system
  Provides callback function (rx_callback) for received TcpIp messages.   
*)
FUNCTION_BLOCK FB_LineCamera EXTENDS FB_CameraTcpIp IMPLEMENTS I_Simulation

VAR_INPUT
  InTempActValueScanner   AT%I* : INT;    (*Actual value temperature camera [0.1 C]*)
  InTempActValuePrintUnit       : INT;    (*Actual value temperature pu [0.1 C]*)
  IfSpeed                       : LREAL;  (*Actual speed [m/s]*)
END_VAR

VAR
  _fCameraWidthNormal       : LREAL;       (*cW: Camera width [m]*)
  _nCameraWidth             : DINT;        (*Camera width [px]*)
  _fCameraMechOffsetTC      : LREAL;       (*Camera mechanical offset at calibration temp [mm]*)
  _fMechOffsetCameraToPU    : LREAL;       (*Camera mechanical offset to PrintUnit [mm]*)
  _fPrintUnitMechOffsetTC   : LREAL;       (*PrintUnit mechanical offset at calibration temp [mm]*)
  _nPrintUnitWidthNormal    : UDINT;       (*Print unit width [px] native*)
  _fPrintUnitWidthTC         : LREAL;       (*pWc: Print unit width [m]*)
  _fPrintUnitCalTemp         : LREAL;       (*calibration temperature for the PrintUnit*)

  fCameraWidthTC            : LREAL;       (*cWc: Camera width [m] at specific calibration temperature*)
  fCameraTemp               : LREAL;       (*Camera actual temp [°C]*)
  fCameraDeltaTempFactor    : LREAL;       (*Factor for distance calculation at delta temp*)
  fCameraRealResolution     : LREAL;       (*real resolution (with the actual temperature) from the line camera in y direction*)
  fCameraMechOffsetTAct     : LREAL;       (*Camera mechanical offset at actual temp [mm]*)
  fCameraCenterOffsetTAct   : LREAL;       (*Camera center offset at actual temp [mm]*)
  
  fPrintUnitTemp            : LREAL;       (*PrintUnit actual temp [°C]*)
  fPrintUnitDeltaTempFactor : LREAL;       (*Factor for distance calculation at delta temp*)
  fPrintUnitMechOffsetTAct  : LREAL;       (*PrintUnit mechanical offset at actual temp [mm]*)
  fPrintUnitWidthTAct       : LREAL;       (*PrintUnit width at actual temp [mm]*)
  fPrintUnitWidthDiff       : LREAL;       (*PrintUnit width difference at actual temp [mm]*)
  fPrintUnitCenterOffsetTAct: LREAL;       (*PrintUnit center offset at actual temp [mm]*)

  fCameraDelay              : LREAL;      (*camera start delay from frame grabber (300dpi vs 600dpi phase sync.) in [m]*)            
  
  nNbVersion                : INT;
  sModus                    : T_MaxString;
  nSector                   : DINT;
  nNbMarks                  : UDINT;
  _bTeachOk                 : BOOL;
  nNbMarksTeach             : UDINT;
  nNbMarksScanned           : UDINT;
  nNbSectorTeach            : DINT;
  sTeach                    : T_MaxString;      // last teach message (255 chars only), for VISU only
  sCameraPoints             : ARRAY [1..GVL_Camera.cMaxNbMarks] OF ST_CameraPoint;   // camera points list of received 'A' frames, also used for 'T' at job start
  sTeachPoints              : ARRAY [1..GVL_Camera.cMaxNbMarks] OF ST_TeachPoint;    // teached points
  nNumPointsPerSectorT      : ARRAY [1..GVL_Camera.cMaxNbSectors] OF DINT;           // number of marks in theach in frame x
  nNumPointsPerSectorA      : ARRAY [1..GVL_Camera.cMaxNbSectors] OF DINT;           // number of marks received in frame x
  nNumFrames                : UDINT;                                      // number of camera frames for job
  
  // Messages
  fbMsg_NotEnoughTeachPoints  : FB_MESSAGE;
  bNotEnoughTeachPoints : BOOL;
  bNotAllFramesContainTeachPoints : BOOL;
  bInvalidTeachPointsReceived : BOOL;
  
  // debug ------------------------
  _bVerbose                 : BOOL;   // Enable verbose mode (log more debug information
  // camera timing
  // - loop test (PLC->QR->PLC)
  _bTestTx                  : BOOL; // send a message (loop time test) from VISU button
  _tTimeTx, _tTimeRx        : T_DCTIME64;
  _sTimeElapsed             : STRING;
  _tTimeTrigger             : T_DCTIME64;
  _nTimeFrameIdx_CamMsg     : UDINT := 1;
  _tTimeFrames_CamMsg       : ARRAY[0..20] OF T_DCTIME64;   // TimeStamp of cam messages
  _tTimeFramesMs_CamMsg     : ARRAY[0..20] OF LREAL;        // elapsed times of each frame since trigger
  _tTimeFrames_TestMsg      : ARRAY[0..20] OF T_DCTIME64;  // TimeStamp of test messages
  _tTimeFramesMs_TestMsg    : ARRAY[0..20] OF LREAL;       // elapsed time of each frame since trigger 
  // tcp camera simulation
  _nSimMode                 : UDINT := 0; // 0=generate points in plc, 1=use ext. cam simulation script, 2=send rx_callback messages directly
  _aCamSimScriptPath        : T_MaxString;
  fbScriptCamSim            : FB_ScriptLauncher;    // external cam simulation script
  _rfTrigSim                : RF_TRIG;
  _tStartSim                : TON;
  // ---- NOTE: vars accesses by CameraSimulation script, edit on both sides
  nScriptPID                : UDINT;
  nFrameNr                  : UDINT;
  // -----
END_VAR                     

VAR CONSTANT
  // protocol
  cErrorString              : T_MaxString := '<Error(';  (*not used yet*)
  cStartString              : T_MaxString := '<position(';
  cEndingString             : T_MaxString := ');';
  cProtoVersion_100         : INT := 100;               // initial protocol version
  cProtoVersion_110         : INT := 110;               // protocol extension +sector indication in T and A +end sector indication
  cIdxFirstSector           : UDINT := 1;
  
  // camera
  cCameraMinXY              : DINT := 0;       (*[px/4800dpi]*)
  cCameraMaxXY              : DINT := 205_000; (*[px/4800dpi]*)
  cCameraResolution         : LREAL := 300;     (*Camera pixel resolution [dpi]*)
  cCameraResolutionSubpixel : LREAL :=  16;     (*Subpixel point resolution [SubPx] -> 4800dpi*)
  cCameraTempCoefficient    : LREAL := 23.1E-6; (*thermal expansion coefficient from aluminium [1/K]*)
  // print unit
  cPrintUnitTempCoefficient : LREAL := 17.3E-6; (*thermal expansion coefficient from print unit base plate [1/K]*)
  fC_PhPixelDistFactorAtRefTemp: LREAL := 0.1693/4;(*RICOH GEN5 PH pixel distance [mm] y direction of one pixel at reference temperature (instead of native resolution 600dpi)*)
  fC_PhPixelDistRefTemp     : LREAL := 23;      (*RICOH GEN5 PH reference temperature matching the fC_PhPixelDistFactorAtRefTemp*)

  // test telegram definitions
  sQvTest_Header            : STRING := 'QT_'; // qualivision test telegram header
  sQvTest_CI                : STRING := 'CI_'; // input frame timing test
  sQvTest_Loop              : STRING := 'LP_'; // loop timing test
END_VAR

VAR PERSISTENT
  fCameraResolution         : LREAL := cCameraResolution;  (*Camera pixel resolution [dpi]*)
  fCameraAdjustmentY        : LREAL := 0;            (*Camera adjustment in Y direction [mm]*)
  fCameraCalTemp            : LREAL := 25;           (*calibration temperature for the given line camera resolution*)    
  fCameraStartMargin        : LREAL := 0.0085;       (*cM: Camera start margin [m]*)
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// - live configuration update & checks
// -- trigger, cam position and trigger settings (Worker position setup)
_fTriggerDistance    := _fDetectToCameraOffset - fCameraStartMargin;
IF IfSpeed <> 0 THEN
  _fTriggerPulseLength := (fSubstrateLength + 2*fCameraStartMargin) / IfSpeed * 1000;  (*[ms] Margin at start and end of the sheet*)
END_IF

// --
IF fCameraResolution > 0 THEN
  fCameraWidthTC := DINT_TO_LREAL(_nCameraWidth) / fCameraResolution * 0.0254;
ELSE
  fCameraWidthTC := FC_CONV_SUBPX_TO_M( _nCameraWidth, LREAL_TO_UDINT(cCameraResolution), 1);
END_IF;

(*Camera temperature compensation (y-pos, center and resolution)*)
fCameraTemp             := INT_TO_LREAL(InTempActValueScanner) * 0.1;
fCameraDeltaTempFactor  := 1 + (cCameraTempCoefficient * (fCameraTemp - fCameraCalTemp));
fCameraRealResolution   := fCameraResolution / fCameraDeltaTempFactor; 
fCameraMechOffsetTAct   := _fCameraMechOffsetTC * fCameraDeltaTempFactor;
fCameraCenterOffsetTAct := (((fCameraWidthTC / 2 * 1000) + _fCameraMechOffsetTC) * fCameraDeltaTempFactor) - ((fCameraWidthTC / 2 * 1000) + _fCameraMechOffsetTC);

fPrintUnitTemp             := INT_TO_LREAL(InTempActValuePrintUnit) * 0.1;
fPrintUnitDeltaTempFactor  := 1 + (cPrintUnitTempCoefficient * (fPrintUnitTemp - _fPrintUnitCalTemp));
fPrintUnitMechOffsetTAct   := _fPrintUnitMechOffsetTC * fPrintUnitDeltaTempFactor;
fPrintUnitWidthTAct        := _fPrintUnitWidthTC * fPrintUnitDeltaTempFactor;

fPrintUnitWidthDiff        := fPrintUnitWidthTAct - _fPrintUnitWidthTC;
fPrintUnitCenterOffsetTAct := (((_fPrintUnitWidthTC / 2 * 1000) + _fPrintUnitMechOffsetTC) * fPrintUnitDeltaTempFactor) - ((_fPrintUnitWidthTC / 2 * 1000) + _fPrintUnitMechOffsetTC);

SimUpdate();

// Messages
(*fbMsg_NotEnoughTeachPoints( bI_Status:=SEL(_bActivated, FALSE, bNotEnoughTeachPoints), 
                             iI_MsgNumber:=eC_DMAX_CAM_NOTENGOUGH_TEACH_POINTS, 
                             iI_MsgLocation:=ePr_BLK_CAMERA,
                             pI_MsgConfig:=_pMsgConfig);
*)
]]></ST>
    </Implementation>
    <Folder Name="I_Simulation" Id="{c9ac893d-3196-4f97-b905-933fa9169f85}" />
    <Method Name="binarySearch" Id="{ec9741bc-2bbe-4c20-8c7d-1086ec7b5bc3}">
      <Declaration><![CDATA[METHOD PRIVATE binarySearch : DINT
VAR_INPUT
  nLow : DINT;     // range lower
  nHigh : DINT;    // range upper
  nKey  : DINT;    // key to search
END_VAR
VAR
  mid : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nHigh < nLow THEN
  binarySearch := -1;
  RETURN;
END_IF

// split array in half
mid := (nLow + nHigh) / 2; (*low + (high - low)/2;*)

// did we find it?
IF nKey = TO_DINT(sTeachPoints[mid].id) THEN
  binarySearch := mid;
  RETURN;
END_IF

// no, search upper half (recursive)
IF nKey > TO_DINT(sTeachPoints[mid].id) THEN
  binarySearch := THIS^.binarySearch((mid + 1), nHigh, nKey);
  RETURN;
END_IF

// no, search lower half (recursive)
binarySearch:= THIS^.binarySearch(nLow, (mid - 1), nKey);]]></ST>
      </Implementation>
    </Method>
    <Property Name="bSimEnable" Id="{b6a9c427-c4f2-4033-a2ee-2748b17341ab}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[PROPERTY bSimEnable : BOOL
]]></Declaration>
      <Get Name="Get" Id="{7354722b-5fee-4faf-9fd2-4a1db0d19f3f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSimEnable:=_bSimulate;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{aac435b7-0dac-41f1-bf73-0a4f618ce06f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bSimulate:=bSimEnable;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="calcTeachPoints" Id="{472c605e-afa9-492a-94ec-73584efe23a0}">
      <Declaration><![CDATA[(*
  Calculate teached/saved reference points in print system coordinates.
*)
METHOD PRIVATE calcTeachPoints
VAR
  nCounter  : UDINT;
  nCurrSect : DINT;
  nErrCtr   : UDINT;
  x_ref_abs : LREAL;
  y_ref_abs : LREAL;
  sTP       : ST_TeachPoint;
  sTPSend   : ST_DeformationPointAccurate;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='calculateTeachPoints()'); END_IF

bInvalidTeachPointsReceived := FALSE;

(*-- sort list with camera/teach points for faster binary searching later*)
sortPoints();

(*-- convert & save teach point in table separate table for later use*)
FOR nCounter := 1 TO nNbMarksTeach DO
  //--- save id
  sTP.id := sCameraPoints[nCounter].id;
  sTP.valid := sCameraPoints[nCounter].valid;
  
  //--- translate to print system coordinate system 
  IF (sCameraPoints[nCounter].x_ref = 0) THEN
    (*Fully automatic mode: ref value from camera is zero, ref value for printer is set with x.*)
    sTP.y_ref_Print   :=   ((_fPrintUnitWidthTC/2 + _fCameraWidthNormal/2) * 1000)  (*[m] => [mm]*)
                         - (  DINT_TO_REAL(sCameraPoints[nCounter].x)
                            / (cCameraResolution * cCameraResolutionSubpixel) * 25.4)           (*[mm]*)
                         - ((_fCameraWidthNormal - LREAL_TO_REAL(_fImageWidth)) * 1000 / 2);     (*[m] => [mm]*)
    sTP.y_teach_Print := 0;
  ELSE
    (*Semi automatic mode: ref value for printer is calculated with ref value and lx from camera.*)
    sTP.y_ref_Print   :=   (DINT_TO_REAL(sCameraPoints[nCounter].x_ref  - sCameraPoints[nCounter].lx)
                                      / (fCameraRealResolution * cCameraResolutionSubpixel) * 25.4);  (*[mm]*)
    sTP.y_teach_Print :=   (DINT_TO_REAL(sCameraPoints[nCounter].x)
                                      / (fCameraRealResolution * cCameraResolutionSubpixel) * 25.4);  (*[mm]*)
  END_IF
  
  IF (sCameraPoints[nCounter].y_ref = 0) THEN
    (*Fully automatic mode: ref value from camera is zero, ref value for printer is set with y.*)
    sTP.x_ref_Print   :=   (FC_CONV_SUBPX_TO_M( sCameraPoints[nCounter].y
                                              , LREAL_TO_UDINT(cCameraResolution)
                                              , LREAL_TO_UDINT(cCameraResolutionSubpixel)) * 1000)  (*[m] => [mm]*)
                         + (fCameraStartMargin * 1000);  (*[m] => [mm]*)
    sTP.x_teach_Print := 0;
  ELSE
    (*Semi automatic mode: ref value for printer is calculated with ref value and ly from camera.*)
    sTP.x_ref_Print   :=   (FC_CONV_SUBPX_TO_M( (sCameraPoints[nCounter].y_ref - sCameraPoints[nCounter].ly)
                                              , LREAL_TO_UDINT(cCameraResolution)
                                              , LREAL_TO_UDINT(cCameraResolutionSubpixel)) * 1000);  (*[m] => [mm]*)
    sTP.x_teach_Print :=   (FC_CONV_SUBPX_TO_M( sCameraPoints[nCounter].y
                                              , LREAL_TO_UDINT(cCameraResolution)
                                              , LREAL_TO_UDINT(cCameraResolutionSubpixel)) * 1000);  (*[m] => [mm]*)
  END_IF;
  
  //--- save teach point locally to seperate teach point array (the other one will be used for cam points while receiving) 
  sTeachPoints[nCounter] := sTP;
  
  //--- count points per sector (for error handling)
  IF (sTP.x_teach_Print = 0) THEN    (*Fully Automatic*)
    x_ref_abs := sTP.x_ref_Print;
  ELSE                                           (*Semi-automatic*)        
    x_ref_abs := sTP.x_ref_Print + sTP.x_teach_Print; 
  END_IF
  IF (sTP.y_teach_Print = 0) THEN    (*Fully Automatic*)
    y_ref_abs := sTP.y_ref_Print;
  ELSE                                           (*Semi-automatic*)        
    y_ref_abs := sTP.y_ref_Print + sTP.y_teach_Print;
  END_IF
  
  IF _fFrameLength <> 0 THEN
    nCurrSect := FC_LREAL_TO_DINT(x_ref_abs / _fFrameLength, pI_ConversionErr:=ADR(nErrCtr)) + 1;
    nNumPointsPerSectorT[nCurrSect] := nNumPointsPerSectorT[nCurrSect] + 1;
  END_IF
  
  //--- send teach point to sink (python script)
  IF _iCameraSink <> 0 THEN
    sTPSend.x_ref := x_ref_abs;
    sTPSend.y_ref := y_ref_abs;
    sTPSend.dx    := 0;
    sTPSend.dy    := 0;
    sTPSend.col := nNumPointsPerSectorT[nCurrSect];  // point number in frame
    sTPSend.row := nCurrSect;                        // frame number
    _iCameraSink.AddTeachPoint(sTeachPoint:=sTPSend);
  END_IF
  
  //--- check if every teach point is valid
  IF NOT sTP.valid THEN
    bInvalidTeachPointsReceived := TRUE;
	END_IF
  
END_FOR

// verify the teach
verifyTeachPoints();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CamTrigger" Id="{0395d1fb-fa74-4831-bc00-276211e94682}">
      <Declaration><![CDATA[METHOD CamTrigger
VAR_INPUT
  bOk             : BOOL;     // trigger is ok
	nPos            : DINT;     // camera triggered position
  nPosDeviation   : DINT;     // camera started deviation
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CamTrigger(bOk:=bOk, nPos:=nPos, nPosDeviation:=nPosDeviation);

_tTimeTrigger := F_GetCurDcTaskTime64();    // save trigger time stamp (a little later than the real)
nNbMarksScanned := 0;

_tStartSim(IN:=TRUE, PT:=T#4MS);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CamTriggerDone" Id="{27278f93-fe3d-4059-a3d3-11ff09aa44ff}">
      <Declaration><![CDATA[METHOD CamTriggerDone]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CamTriggerDone();

SimExit();]]></ST>
      </Implementation>
    </Method>
    <Property Name="eCameraMode" Id="{d4155a50-e5e0-4ccf-af89-73b07ac1930f}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY eCameraMode : E_CameraMode
]]></Declaration>
      <Get Name="Get" Id="{8a53b2c7-f7d6-4d1f-a3a2-e2ef18eccb5f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// return active mode (after teach or live
eCameraMode := _eCameraMode;  // mode set by PUC

IF    _eCameraMode = E_CameraMode.Auto THEN
  eCameraMode := _ePossibleMode;
ELSIF _ePossibleMode < _eCameraMode THEN
  // reduced level
  eCameraMode := _ePossibleMode;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="eDeviceType" Id="{df3851f5-4b1e-49f6-8dd1-d2bba09e1eb6}">
      <Declaration><![CDATA[PROPERTY eDeviceType : E_CameraDevice]]></Declaration>
      <Get Name="Get" Id="{ac3142cb-59c7-4ff7-96b4-d4d1d1f4c5be}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eDeviceType := E_CameraDevice.Scanner;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="GetCamStatus" Id="{58717091-2fd6-4ec0-901f-ea336e5595ed}">
      <Declaration><![CDATA[(*
  :return: CamReady 
*)
METHOD GetCamStatus : BOOL
VAR_OUTPUT
  bConnectionOK  : BOOL;    // Camera connected
  bTeachOk       : BOOL;    // Teach successful
  nTeachedPoints : UDINT;   // Teached points for this job
  nScannedPoints : UDINT;   // Scanned points on current sheet  
  bCamStarted    : BOOL;    // Camera trigger is active, cam started
  bCamDone       : BOOL;    // Camera finished on last CT
  bErrors        : ARRAY[1..GVL_Camera.nC_NbCamErrors] OF BOOL;  // generic error flag list
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bConnectionOK  := NOT bConnectionErr OR bSimulate;
bTeachOk       := _bTeachOk OR bSimulate;
nTeachedPoints := nNbMarksTeach;
nScannedPoints := nNbMarksScanned;
bCamStarted    := _bCamStarted;
// camera finished
IF nNbVersion = cProtoVersion_110 THEN
  // Done: Trigger released and last sector was received
  bCamDone       := _bCamDone AND ((nSector >= nNbSectorTeach) OR (nSector = SINT_TO_DINT(-1)));
ELSE
  // Done: Trigger released and same all teached points are scanned // NOTE: this will not work if not all marks are detected by camera
  bCamDone       := _bCamDone AND (nScannedPoints>=nTeachedPoints);
END_IF
GetCamStatus := bConnectionOK AND bTeachOk;   // camera ready]]></ST>
      </Implementation>
    </Method>
    <Method Name="getPointIndex" Id="{e6ce2af3-6e9d-45e3-9234-f92214a4ec5c}">
      <Declaration><![CDATA[(*
  get array index to point ID in stored point table
  :returns: TRUE if found, FALSE else
*)
METHOD getPointIndex : BOOL
VAR_INPUT
  nId : UDINT;
END_VAR
VAR_OUTPUT
  nIndex : UDINT;
END_VAR
VAR
  nResultIdx : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// search corresponding point in table (search for same mark ID)

nResultIdx := binarySearch(1, TO_DINT(nNbMarksTeach), TO_DINT(nId));
IF nResultIdx = -1 THEN
  LogWarning(F_Concat3('Point with Id: ', TO_STRING(nId) , ' not found in saved teach points'));
  nIndex := 1;
  RETURN;
END_IF

nIndex := TO_UDINT(nResultIdx);
getPointIndex := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getSimCamPoint" Id="{eeb86648-0655-4273-a437-ce3be5ec2c20}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD INTERNAL getSimCamPoint : ST_DeformationPointAccurate
VAR_INPUT
  fXMin : LREAL := 0.0;
	fXMax : LREAL := 0.0;
	fYMin : LREAL := 0.0;
	fYMax : LREAL := 0.0;
	
	fOffsetMin : LREAL := 0.0;
	fOffsetMax : LREAL := 0.0;
END_VAR
VAR_OUTPUT
  sO_CamPoint : ST_DeformationPointAccurate;
END_VAR
VAR_INST
  fbRand : DRAND;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbRand();
sO_CamPoint.x_ref := (fXMin + (fXMax - fXMin));
fbRand();
sO_CamPoint.y_ref := (fYMin + (fYMax - fYMin));

fbRand();
sO_CamPoint.dx := (fOffsetMin + (fOffsetMax - fOffsetMin) * fbRand.Num);
fbRand();
sO_CamPoint.dy := (fOffsetMin + (fOffsetMax - fOffsetMin) * fbRand.Num);

getSimCamPoint := sO_CamPoint;]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitLineCamera" Id="{667b3eb2-1237-4402-a607-2ae493c6ef6c}">
      <Declaration><![CDATA[METHOD InitLineCamera
VAR_INPUT
  nPrintUnitResolution         : UDINT;    (*printhead pixel resolution [dpi]*)
  nPrintUnitSubPx              : UDINT;    (*print unit subPixel resolution [SubPx]*)
  nPrintUnitWidth              : UDINT;    (*print unit width in [px]*)
  iCameraTrigger               : I_CameraTrigger;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_fCameraWidthNormal     := FC_CONV_SUBPX_TO_M( _nCameraWidth
                                             , LREAL_TO_UDINT(cCameraResolution)
                                             , 1);
                                             
// TODO: references (global) vars, move them to a init parameter before moving to a library
_nPrintUnitWidthNormal  := nPrintUnitWidth;
_fPrintUnitCalTemp      := fC_PhPixelDistRefTemp;   // reference temperate for real pixel spacing of ph
_fPrintUnitWidthTC      := (nPrintUnitWidth * fC_PhPixelDistFactorAtRefTemp) / 1000;  // caluclate print unit with at calibration temperature [m]

SUPER^.Init( nPrintUnitResolution:=nPrintUnitResolution
           , nPrintUnitSubPx:=nPrintUnitSubPx
           , iCameraTrigger := iCameraTrigger
           , bUseCameraTrigger:=TRUE
           , bUseCameraTriggerFeedback:=TRUE);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitSimulation" Id="{ff9ac191-b4f4-4074-8866-7bea76fbb955}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD InitSimulation : BOOL
VAR_INPUT
  aCamSimScriptPath : T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_aCamSimScriptPath := aCamSimScriptPath;]]></ST>
      </Implementation>
    </Method>
    <Method Name="mJobStart" Id="{26bd3629-7846-4668-8fa6-8d40a8b7782f}">
      <Declaration><![CDATA[METHOD mJobStart : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// re-calculate teach points with previous received 'T' telegram 
//  handles case: teach telegram arrived before JobStart
IF sModus = 'T' THEN calcTeachPoints(); END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_callback" Id="{6b8106b1-1d7c-4264-97b7-e686660985d7}">
      <Declaration><![CDATA[(*
  Tcpip client rx message callback. 
  Called by FB_TcpMsgNotifier, registered with 'registerTcpIpClient()' before.
*)
METHOD rx_callback
VAR_INPUT
	sMessage	: CalmarCompTcpIp.ST_TcpMsg;    // rx message
END_VAR
VAR
  sAnalyzeLastMessage    : STRING(GVL_TcpIp.TCP_RXDATA_SIZE);          // telegram string for analysis
  sTmpCamPoint           : ST_CameraPoint;
  
  nCounter               : UDINT;
  bOk, bEnd              : BOOL;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// basic message handling
SUPER^.rx_callback(sMessage := sMessage);
// debug print
IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug,Msg:=F_Concat4('Sz: ', TO_STRING(nLastMessageSz), ' Msg:', sLastMessage)); END_IF

// check parameter (avoids crash)
IF _fPrintUnitWidthTC = 0 THEN LogError('rx_callback: Invalid configuration, review persistences and config values!'); RETURN; END_IF

// copy for parsing
sAnalyzeLastMessage := sLastMessage;      

REPEAT
  (*--- check message type ---*)
  // -- Is it a test message?
  IF rx_TestMsg(pMessage:=ADR(sLastMessage)) THEN       (*Test message*)
    RETURN;   // test message, ignore rest of parsing
   
  // -- Is it a error message ?
  ELSIF rx_ErrorMsg(pMessage:=ADR(sLastMessage)) THEN   (*Error message*)
    RETURN;   // error message, ignore rest of parsing
  
  // -- Is it a position message ('T' Teach or 'A' Auswertung)
  ELSIF rx_ParseHeader( pAnalyzeLastMessage := ADR(sAnalyzeLastMessage)
                      , nNbVersion      => nNbVersion          (*version*)
                      , sModus          => sModus              (*modus*)
                      , nNbMarks        => nNbMarks            (*number of marks*)
                      , nSector         => nSector)            (*sector*)
    THEN
     // got a position message, do not exit and do rest of parsing below
     // >>> DO parsing below 
     ;
    
  // -- unknown message
  ELSE
    IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('unknown rx message (ignore): ', sLastMessage)); END_IF
    RETURN;
  END_IF
  
  
  (*--- Handle position telegram ---*)
  IF (sModus  = 'T') THEN 
    (*-- 'T' Teach message *)
    nNbMarksTeach   := 0;
    nNbMarksScanned := 0;
    nNbSectorTeach  := nSector;  (*Total number or sectors are send with teach message.*)
    sTeach          := sAnalyzeLastMessage; // display on visu
    
    IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='receive T telegram, erase cam/teach points list'); END_IF    
    MEMSET(destAddr:=ADR(sTeachPoints),  fillByte:=0, n:=SIZEOF(sTeachPoints));   // eraase teach points list
    MEMSET(destAddr:=ADR(sCameraPoints), fillByte:=0, n:=SIZEOF(sCameraPoints));  // erase cam points list
    MEMSET(destAddr:=ADR(nNumPointsPerSectorA), fillByte:=0, n:=SIZEOF(nNumPointsPerSectorA));
    MEMSET(destAddr:=ADR(nNumPointsPerSectorT), fillByte:=0, n:=SIZEOF(nNumPointsPerSectorT));
  ELSE
    (*-- 'A' Auswertung message *)
    sMemLastMessage := sAnalyzeLastMessage; // display on visu
    
    IF nSector = TO_DINT(cIdxFirstSector) THEN  // erase campoint with first received sector
      MEMSET(destAddr:=ADR(sCameraPoints), fillByte:=0, n:=SIZEOF(sCameraPoints));  // erase cam points list
      IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('received first A sector, erase cam points list.','')); END_IF

      _nTimeFrameIdx_CamMsg := 1;
    END_IF
  
    IF _nTimeFrameIdx_CamMsg <= 20 THEN  // save message timestamp for debugging
      _tTimeFrames_CamMsg[_nTimeFrameIdx_CamMsg] := F_GetCurDcTaskTime64();     // save cam frame rx timestamp
      _tTimeFramesMs_CamMsg[_nTimeFrameIdx_CamMsg] := TO_LREAL((_tTimeFrames_CamMsg[_nTimeFrameIdx_CamMsg]-_tTimeTrigger)/EC_DCTIME_TICKSPERMSEC64);
      _nTimeFrameIdx_CamMsg := _nTimeFrameIdx_CamMsg + 1;
    END_IF
    
  END_IF;
  
  
  (*Search for rx, ry, lx, ly, v, x and y*)
  FOR nCounter := 1 TO nNbMarks DO
    // get next point
    IF NOT rx_ParsePoint(pAnalyzeLastMessage:=ADR(sAnalyzeLastMessage), sCamResult=>sTmpCamPoint, bLast=>bEnd) THEN 
      // invalid point received
      LogWarning(F_Concat6('invalid ', SEL(sModus='T', 'camera', 'teach'), ' point received (x/y): ', TO_STRING(sTmpCamPoint.x_ref), '/', TO_STRING(sTmpCamPoint.y_ref)));
    END_IF
    IF bEnd AND nCounter < nNbMarks THEN LogWarning(F_Concat4('Less marks received than indicated in header: ', TO_STRING(nCounter), '<', TO_STRING(nNbMarks))); END_IF
    
    IF (sModus  = 'T') THEN
      (*-- 'T' Teach message *)
      // save (convert with job start)
      saveTeachPoint(sCamPoint := sTmpCamPoint);
    ELSE
      (*-- 'A' Auswertung message *)
      // save & convert cam point
      stCamPoint := saveAuswertungPoint(sCamPoint:=sTmpCamPoint, bOK=>bOk);     
      // stream point (if valid)
      IF sTmpCamPoint.valid AND bOk THEN
        IF _iCameraSink <> 0 THEN
          _iCameraSink.AddCamPoint(stCamPoint);
          IF _bVerbose THEN 
            LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=
                    F_Concat5('x_ref: ' , TO_STRING(stCamPoint.x_ref),' y_ref: ', TO_STRING(stCamPoint.y_ref),
                    F_Concat4(' dx: ' , TO_STRING(stCamPoint.dx),' dy: ', TO_STRING(stCamPoint.dy))));
          END_IF
        END_IF
      END_IF
    END_IF
  END_FOR
UNTIL FIND2(ADR(sAnalyzeLastMessage), ADR(cStartString)) = 0   (*Search for another start string*)
END_REPEAT

IF (sModus  = 'T') THEN calcTeachPoints(); END_IF  // calculate teach points if it was a teach

bMsgReceived := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_DeleteMsgPart" Id="{3ec69420-3186-48ce-92b1-d2dad32e4f68}">
      <Declaration><![CDATA[METHOD PRIVATE rx_DeleteMsgPart
VAR_INPUT
  pAnalyzeLastMessage    : POINTER TO STRING(GVL_TcpIp.TCP_RXDATA_SIZE);  // telegram string for analysis
  nLen                   : UDINT;
  nPos                   : UDINT;
END_VAR
VAR
  sMessageDelete         : STRING(GVL_TcpIp.TCP_RXDATA_SIZE);             // telegram string for analysis
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[DELETE2( pSrcString := pAnalyzeLastMessage
       , pDstString := ADR(sMessageDelete)
       , nDstSize   := SIZEOF(sMessageDelete)
       , nLen       := nLen
       , nPos       := nPos);

pAnalyzeLastMessage^ := sMessageDelete;]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_ErrorMsg" Id="{29598a7c-0ad6-4ff3-8dcd-ec5516147256}">
      <Declaration><![CDATA[(*
  Parse for error message
  :return: TRUE if it was an error test telegram, FALSE if other.
*)
METHOD PRIVATE rx_ErrorMsg : BOOL
VAR_INPUT
  pMessage    : POINTER TO STRING(GVL_TcpIp.TCP_RXDATA_SIZE);   // tcp message string pointer 
END_VAR
VAR
  nFIdx : UDINT;    // string find index
  nFrmIdx : UDINT;
  tDiff : LREAL;
  sErrMsg : T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// parse message type
nFIdx := FIND2(pMessage, ADR(cErrorString));
IF nFIdx > 0 THEN  
  IF _bVerbose THEN LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('error: msg received: ', pMessage^)); END_IF

  // error telegram received
  DELETE2( pSrcString := pMessage
         , pDstString := ADR(sErrMsg)
         , nDstSize   := SIZEOF(sErrMsg)
         , nLen       := (nFIdx + INT_TO_UDINT(LEN(cErrorString)) - 1)
         , nPos       := 1);

  // strip other control characters
  FindAndDelete(pSrcString:=ADR(sErrMsg), pDstString:=ADR(sErrMsg), nDstSize:=SIZEOF(sErrMsg), pDeleteString:=ADR(cEndingString));
  
  // error message implement handling
  
  rx_ErrorMsg := TRUE;
ELSE
  ; // other telegram
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_ParseHeader" Id="{04b20f7e-2664-46bd-a012-2ae575633da0}">
      <Declaration><![CDATA[(*
  Parse for position telegram header.
  :return: TRUE if valid position telegram, FALSE else
*)
METHOD PRIVATE rx_ParseHeader : BOOL
VAR_INPUT
  pAnalyzeLastMessage    : POINTER TO STRING(GVL_TcpIp.TCP_RXDATA_SIZE);  // telegram string for analysis
END_VAR
VAR_OUTPUT
  nNbVersion             : INT;                   (*(V) Version: protocol version, e.g. 100/110/...*)
  sModus                 : T_MaxString;           (*(M) Modus: 'T'/'A'*)
  nNbMarks               : UDINT;                 (*(A) Merkmale: number of Marks in Teach/Auswertung*)
  nSector                : DINT;                  (*(S) Sectors: Number of Sectors in 'T' / Sector index in 'A'*)
  //sMemLastMessage        : STRING(GVL_TcpIp.TCP_RXDATA_SIZE);  (*rx telegram string without header*)
END_VAR
VAR
  nFindIndex             : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Search for start string*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(cStartString));
IF nFindIndex = 0 THEN RETURN; END_IF

(*Search string found => remove string to evaluate rest of message*)
rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := (nFindIndex + INT_TO_UDINT(LEN(cStartString)) - 1) , nPos := 1);

(*Search for version number*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  nNbVersion := STRING_TO_INT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
END_IF;

(*Search for modus (M)*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sModus := LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1));

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
END_IF;

(*Search for number marks (A)*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  nNbMarks := STRING_TO_UDINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));
  IF nNbMarks > GVL_Camera.cMaxNbMarks THEN
    LogLvl(Lvl:=E_LogSeverity.Warning, Msg:=F_Concat4('Limit marks (', TO_STRING(nNbMarks),') to max=', TO_STRING(GVL_Camera.cMaxNbMarks)));
    nNbMarks := GVL_Camera.cMaxNbMarks;
  END_IF

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
END_IF;

(*Search for sector of transmission (S)*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  (*Last sector is indicated with '-1'*)
  nSector := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  // end of message detected
  nFindIndex := FIND2(pAnalyzeLastMessage, ADR(');'));
  IF nFindIndex > 0 THEN
    (*Last sector is indicated with '-1'*)
    nSector := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));
  
    rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex + 1, nPos := 1);
  END_IF;
END_IF;

rx_ParseHeader := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_ParsePoint" Id="{ea6a77bc-4be1-4689-a567-439afdc9dfa7}">
      <Declaration><![CDATA[(*
  Parse a point entry from string.
  And removes this string part from pAnalyzeLastMessage.
  :return: TRUE if point is valid
*)
METHOD PRIVATE rx_ParsePoint : BOOL
VAR_INPUT
  pAnalyzeLastMessage    : POINTER TO STRING(GVL_TcpIp.TCP_RXDATA_SIZE);  // telegram string for analysis
END_VAR
VAR_OUTPUT
  sCamResult             : ST_CameraPoint;
  bLast                  : BOOL;
END_VAR
VAR
  nFindIndex             : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Index of mark (T)*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.id := STRING_TO_UDINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));
  
  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
END_IF;

(*rx*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.x_ref := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.x_ref < cCameraMinXY)
     OR (sCamResult.x_ref > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;
(*ry*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.y_ref := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.y_ref < cCameraMinXY)
     OR (sCamResult.y_ref > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;

(*lx*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.lx := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.lx < cCameraMinXY)
     OR (sCamResult.lx > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;
(*ly*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.ly := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.ly < cCameraMinXY)
     OR (sCamResult.ly > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;

(*v*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  IF STRING_TO_INT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1))) = 1 THEN
    sCamResult.valid := TRUE;
  ELSE
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;
(*x*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF nFindIndex > 0 THEN
  sCamResult.x := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.x < cCameraMinXY)
     OR (sCamResult.x > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  sCamResult.valid := FALSE;
END_IF;
(*y*)
nFindIndex := FIND2(pAnalyzeLastMessage, ADR(','));
IF (nFindIndex > 0) AND (nFindIndex <= 8) THEN  (*nFindIndex is > 8 if a second message is in the frame*)
  sCamResult.y := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));

  IF    (sCamResult.y < cCameraMinXY)
     OR (sCamResult.y > cCameraMaxXY)
  THEN
    sCamResult.valid := FALSE;
  END_IF;

  rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex , nPos := 1);
ELSE
  nFindIndex := FIND2(pAnalyzeLastMessage, ADR(');'));
  IF nFindIndex > 0 THEN
    sCamResult.y := STRING_TO_DINT(LEFT(pAnalyzeLastMessage^, (UDINT_TO_INT(nFindIndex) - 1)));
    bLast := TRUE;
    IF    (sCamResult.y < cCameraMinXY)
       OR (sCamResult.y > cCameraMaxXY)
    THEN
      sCamResult.valid := FALSE;
    END_IF;

    rx_DeleteMsgPart(pAnalyzeLastMessage := pAnalyzeLastMessage, nLen := nFindIndex + 1, nPos := 1);
  ELSE
    sCamResult.valid := FALSE;
  END_IF;
END_IF;

rx_ParsePoint := sCamResult.valid;]]></ST>
      </Implementation>
    </Method>
    <Method Name="rx_TestMsg" Id="{47666657-5910-41e1-8bbf-f2d5f50d0ccf}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[(*
  Parse rx test telegrams.
  :return: TRUE if it was a known test telegram, FALSE if other.
*)
METHOD PRIVATE rx_TestMsg : BOOL
VAR_INPUT
  pMessage    : POINTER TO STRING(GVL_TcpIp.TCP_RXDATA_SIZE);   // tcp message string pointer 
END_VAR
VAR
  nFIdx : UDINT;    // string find index
  nFrmIdx : UDINT;
  tDiff : LREAL;
  sTestMsg : T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// rx timestamp
_tTimeRx := F_GetCurDcTaskTime64();

// parse message type
nFIdx := FIND2(pMessage, ADR(sQvTest_Header));
IF nFIdx > 0 THEN  
  IF _bVerbose THEN
    LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('test_rx: msg received: ', pMessage^));
  END_IF
  
  // test telegram received
  DELETE2( pSrcString := pMessage
         , pDstString := ADR(sTestMsg)
         , nDstSize   := SIZEOF(sTestMsg)
         , nLen       := (nFIdx + INT_TO_UDINT(LEN(sQvTest_Header)) - 1)
         , nPos       := 1);

  // strip QR start and end characters
  FindAndDeleteChar(pSrcString:=ADR(sTestMsg), pDstString:=ADR(sTestMsg), nDstSize:=SIZEOF(sTestMsg), sDeleteChar:='<');
  FindAndDeleteChar(pSrcString:=ADR(sTestMsg), pDstString:=ADR(sTestMsg), nDstSize:=SIZEOF(sTestMsg), sDeleteChar:=';');
  
  // Parse per test message type, e.g.  <QR_CI_1;
  // -- qv input frame timing test
  IF sQvTest_CI = LEFT(sTestMsg, LEN(sQvTest_CI)) THEN
    // strip header and test indication
    DELETE2( pSrcString := ADR(sTestMsg)
           , pDstString := ADR(sTestMsg)
           , nDstSize   := SIZEOF(sTestMsg)
           , nLen       := (1 + INT_TO_UDINT(LEN(sQvTest_CI)) - 1)
           , nPos       := 1);
    // frame number
    nFrmIdx := TO_UINT(sTestMsg);
    IF nFrmIdx <= 20 THEN
      _tTimeFrames_TestMsg[nFrmIdx] := F_GetCurDcTaskTime64();     // save test input frame timestamp
      _tTimeFramesMs_TestMsg[nFrmIdx] := TO_LREAL((_tTimeFrames_TestMsg[nFrmIdx]-_tTimeTrigger)/EC_DCTIME_TICKSPERMSEC64);
    END_IF
    rx_TestMsg := TRUE;
    
  // -- qv loop time test frame response
  ELSIF sQvTest_Loop = LEFT(sTestMsg, LEN(sQvTest_Loop)) THEN
    tDiff := TO_LREAL((_tTimeRx - _tTimeTx) / EC_DCTIME_TICKSPERMSEC64); // calc time elapsed in [ms]
    _sTimeElapsed := F_Concat2(TO_STRING(tDiff),'ms');
    LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('rx_test: Loop time=', _sTimeElapsed));
    rx_TestMsg := TRUE;
  
  // -- unknown test message
  ELSE
    ;
	END_IF
ELSE
  ; // other telegram
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="saveAuswertungPoint" Id="{7d975ad2-a042-4728-b5d9-d34b3daaf03e}">
      <Declaration><![CDATA[METHOD PRIVATE saveAuswertungPoint : ST_DeformationPointAccurate
VAR_INPUT
  sCamPoint : ST_CameraPoint;
END_VAR
VAR_OUTPUT
  bOK : BOOL;
END_VAR
VAR
  nMarkIndex        : UDINT;
  fDistortionFactor : LREAL;                 (*distortion factor*)
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*convert and save Auswertungs point*)
IF NOT getPointIndex(nId:=sCamPoint.id, nIndex=>nMarkIndex) THEN
  LogError(F_Concat3('Auswertung point with Id: ', TO_STRING(sCamPoint.id), ' not found, ignore'));
  bOK := FALSE;
  RETURN;
END_IF

(*----- calculate print point position -----*)
(*Actual position of distinctive mark*)
(*NOTE: camera points have a different resolution! camera 300dpi * 16=4800dpi*)
IF sTeachPoints[nMarkIndex].x_teach_Print = 0 THEN 
  (*Fully automatic mode*)
  sTeachPoints[nMarkIndex].x_Print := FC_CONV_SUBPX_TO_M( sCamPoint.y
                                                          , LREAL_TO_UDINT(cCameraResolution)
                                                          , LREAL_TO_UDINT(cCameraResolutionSubpixel)) * 1000;  (*[m] => [mm]*)
ELSE
  (*Semi automatic mode*)
  sTeachPoints[nMarkIndex].x_Print :=     sTeachPoints[nMarkIndex].x_ref_Print
                                        + sTeachPoints[nMarkIndex].x_teach_Print
                                        - FC_CONV_SUBPX_TO_M( sCamPoint.y
                                                            , LREAL_TO_UDINT(cCameraResolution)
                                                            , LREAL_TO_UDINT(cCameraResolutionSubpixel)) * 1000;  (*[m] => [mm]*)
END_IF;
IF sTeachPoints[nMarkIndex].y_teach_Print = 0 THEN 
  (*Fully automatic mode*)
  sTeachPoints[nMarkIndex].y_Print :=   ((fPrintUnitWidthTAct/2 + fCameraWidthTC/2) * 1000)  (*[m] => [mm]*)
                                        - (  DINT_TO_LREAL(sCamPoint.x)
                                           / (fCameraRealResolution * cCameraResolutionSubpixel) * 25.4);  (*[mm]*)
ELSE
  (*Semi automatic mode*)
  sTeachPoints[nMarkIndex].y_Print :=     sTeachPoints[nMarkIndex].y_ref_Print
                                        + sTeachPoints[nMarkIndex].y_teach_Print
                                        - (  DINT_TO_LREAL(sCamPoint.x)
                                           / (fCameraRealResolution * cCameraResolutionSubpixel) * 25.4);  (*[mm]*)
END_IF;

// save cam point for visu
sCameraPoints[nMarkIndex] := sCamPoint;

(*----- create cam correction point -----*)
(*NOTE: correction will be rounded to [px]*)
saveAuswertungPoint.x_ref := F_MeterToSubPixelReal( sTeachPoints[nMarkIndex].x_ref_Print * 0.001      (*[mm] => [m]*)
                                     , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)                           
saveAuswertungPoint.y_ref := F_MeterToSubPixelReal( sTeachPoints[nMarkIndex].y_ref_Print * 0.001      (*[mm] => [m]*)
                                     , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)       
fCameraDelay := F_SubPixelToMeter(lPosSubPx:=_nCamStartPosDeviation, fResSubPx:=UDINT_TO_LREAL(_nPrintUnitResolution*_nPrintUnitSubPx));
saveAuswertungPoint.dx    := F_MeterToSubPixelReal( (sTeachPoints[nMarkIndex].x_ref_Print - sTeachPoints[nMarkIndex].x_Print) * 0.001  (*[mm] => [m]*)
                                     + fCameraDelay                                        (*apply camera trigger jitter*)
                                     , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
                                     
(*Distortion due to expansion of print unit, calculate factor*)
fDistortionFactor := ((_fPrintUnitWidthTC / 2 * 1000) - sTeachPoints[nMarkIndex].y_ref_Print) / (_fPrintUnitWidthTC / 2 * 1000);
saveAuswertungPoint.dy := F_MeterToSubPixelReal( (  (sTeachPoints[nMarkIndex].y_ref_Print - sTeachPoints[nMarkIndex].y_Print)
                                     + fCameraAdjustmentY
                                     + ((fPrintUnitWidthDiff * 1000 / 2) * fDistortionFactor)   (*Distortion due to expansion of print unit*)
                                     + (fPrintUnitCenterOffsetTAct - fCameraCenterOffsetTAct)   (*Compensation due to unilateral expansion*)
                                    ) * 0.001  (*[mm] => [m]*)
                                  , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
                                  
// not used entries
saveAuswertungPoint.index := 0; // optional: TO_DINT(sCamPoint.id);
saveAuswertungPoint.col := 0;
saveAuswertungPoint.row := 0;
IF NOT sCamPoint.valid THEN
  saveAuswertungPoint.dx := 0;
  saveAuswertungPoint.dy := 0;
ELSE
  bOK := TRUE;
END_IF
nNbMarksScanned := nNbMarksScanned + 1;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="saveTeachPoint" Id="{90d49940-4880-47c2-acae-4aab8354502f}">
      <Declaration><![CDATA[METHOD PRIVATE saveTeachPoint
VAR_INPUT
  sCamPoint : ST_CameraPoint;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*save teach point in table*)
// NOTE: mark ID unique and does not match the array index! 
IF nNbMarksTeach = GVL_Camera.cMaxNbMarks THEN 
  LogLvl(Lvl:=E_LogSeverity.Error, Msg:=F_Concat4('Too many marks received max. allowed: ', TO_STRING(GVL_Camera.cMaxNbMarks), ' ignore mark with id:', TO_STRING(sCamPoint.id)));
  RETURN;
END_IF

// save next teach mark
nNbMarksTeach := nNbMarksTeach + 1;
sCameraPoints[nNbMarksTeach] := sCamPoint;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="setCameraMode" Id="{e466ad03-16f0-4bc5-b2c3-dc6093ffa617}">
      <Declaration><![CDATA[(*
  Set mode to camera.
  :return: TRUE if success
*)
METHOD setCameraMode : BOOL
VAR_INPUT
  eCameraMode : E_CameraMode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eCameraMode = E_CameraMode.XYR OR   // supported modi
   eCameraMode = E_CameraMode.Auto OR
   eCameraMode = E_CameraMode.Live OR 
   eCameraMode = E_CameraMode.Trend THEN
   
  _eCameraMode := eCameraMode;  // set desired mode
  setCameraMode := TRUE;
ELSE
  LogError(F_Concat3('Camera mode=', TO_STRING(eCameraMode), ' not supported by camera'));
  _eCameraMode := E_CameraMode.NoCorrection;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimEnter" Id="{eab99473-fa8e-4b10-9b13-1e9a04f3b2f2}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD SimEnter : BOOL
VAR_INST
  sSimMsg         : CalmarCompTcpIp.ST_TcpMsg;
  nFrameSize      : UDINT := 2048;
  nMarksPerFrame  : UDINT := 4;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bSimEnable THEN RETURN; END_IF

IF    _nSimMode = 0 THEN
   nNbMarksTeach := 4; // just somebigger than 2
   nNbMarks := nNbMarksTeach;
ELSIF _nSimMode = 1 THEN
  // use external camera simulation script
  nFrameNr := 0;
ELSIF _nSimMode = 2 THEN
  // send directly some messages
  sSimMsg.stRemoteAddr.sAddr:='127.0.0.1';
  sSimMsg.stRemoteAddr.nPort:=3000;
  //v100 teach
  //rx_callback(sMessage:='<position(100,T,39,3,125,0,0,0,0,1,7184,7184,126,0,0,0,0,1,7184,26080,127,0,0,0,0,1,7184,35520,128,0,0,0,0,1,7184,54416,129,0,0,0,0,1,7168,73312,130,0,0,0,0,1,7184,82768,131,0,0,0,0,1,7184,101664,132,0,0,0,0,1,7184,120560,133,0,0,0,0,1,7184,139456,134,0,0,0,0,1,7184,148912,135,0,0,0,0,1,7184,167808,136,0,0,0,0,1,7168,186704,137,0,0,0,0,1,63872,7184,138,0,0,0,0,1,63872,26080,139,0,0,0,0,1,63872,35520,140,0,0,0,0,1,63872,54416,141,0,0,0,0,1,63872,73312,142,0,0,0,0,1,63872,82768,143,0,0,0,0,1,63872,101664,144,0,0,0,0,1,63872,120560,145,0,0,0,0,1,63872,139456,146,0,0,0,0,1,63872,148912,147,0,0,0,0,1,63872,167808,148,0,0,0,0,1,63872,186704,149,0,0,0,0,1,130016,7168,150,0,0,0,0,1,130016,26080,151,0,0,0,0,1,130016,35520,152,0,0,0,0,1,130016,54416,153,0,0,0,0,1,130016,73312,154,0,0,0,0,1,130016,82768,155,0,0,0,0,1,130016,101664,156,0,0,0,0,1,130016,120560,157,0,0,0,0,1,130016,139456,158,0,0,0,0,1,130016,148912,159,0,0,0,0,1,130016,167808,160,0,0,0,0,1,130016,186704,161,0,0,0,0,1,35520,7168,162,0,0,0,0,1,35520,5441);');
  //v110 teach
  sSimMsg.sMessage:= '<position(110,T,38,12,1,0,0,0,0,1,7184,7184,2,0,0,0,0,1,7184,26080,4,0,0,0,0,1,7184,35520,128,0,0,0,0,1,7184,54416,5,0,0,0,0,1,7168,73312,130,0,0,0,0,1,7184,82768,131,0,0,0,0,1,7184,101664,132,0,0,0,0,1,7184,120560,133,0,0,0,0,1,7184,139456,134,0,0,0,0,1,7184,148912,135,0,0,0,0,1,7184,167808,136,0,0,0,0,1,7168,186704,137,0,0,0,0,1,63872,7184,138,0,0,0,0,1,63872,26080,139,0,0,0,0,1,63872,35520,140,0,0,0,0,1,63872,54416,141,0,0,0,0,1,63872,73312,142,0,0,0,0,1,63872,82768,143,0,0,0,0,1,63872,101664,144,0,0,0,0,1,63872,120560,145,0,0,0,0,1,63872,139456,146,0,0,0,0,1,63872,148912,147,0,0,0,0,1,63872,167808,148,0,0,0,0,1,63872,186704,149,0,0,0,0,1,130016,7168,150,0,0,0,0,1,130016,26080,151,0,0,0,0,1,130016,35520,152,0,0,0,0,1,130016,54416,153,0,0,0,0,1,130016,73312,154,0,0,0,0,1,130016,82768,155,0,0,0,0,1,130016,101664,156,0,0,0,0,1,130016,120560,157,0,0,0,0,1,130016,139456,158,0,0,0,0,1,130016,148912,159,0,0,0,0,1,130016,167808,160,0,0,0,0,1,130016,186704,161,0,0,0,0,1,35520,7168,162,0,0,0,0,1,35520,5441);';
  //points 1 to 38
  //sSimMsg.sMessage:= '<position(110,T,38,12,1,0,0,0,0,1,7184,7184,2,0,0,0,0,1,7184,26080,3,0,0,0,0,1,7184,35520,4,0,0,0,0,1,7184,54416,5,0,0,0,0,1,7168,73312,6,0,0,0,0,1,7184,82768,7,0,0,0,0,1,7184,101664,8,0,0,0,0,1,7184,120560,9,0,0,0,0,1,7184,139456,10,0,0,0,0,1,7184,148912,11,0,0,0,0,1,7184,167808,12,0,0,0,0,1,7168,186704,13,0,0,0,0,1,63872,7184,14,0,0,0,0,1,63872,26080,15,0,0,0,0,1,63872,35520,16,0,0,0,0,1,63872,54416,17,0,0,0,0,1,63872,73312,18,0,0,0,0,1,63872,82768,19,0,0,0,0,1,63872,101664,20,0,0,0,0,1,63872,120560,21,0,0,0,0,1,63872,139456,22,0,0,0,0,1,63872,148912,23,0,0,0,0,1,63872,167808,24,0,0,0,0,1,63872,186704,25,0,0,0,0,1,130016,7168,26,0,0,0,0,1,130016,26080,27,0,0,0,0,1,130016,35520,28,0,0,0,0,1,130016,54416,29,0,0,0,0,1,130016,73312,30,0,0,0,0,1,130016,82768,31,0,0,0,0,1,130016,101664,32,0,0,0,0,1,130016,120560,33,0,0,0,0,1,130016,139456,34,0,0,0,0,1,130016,148912,35,0,0,0,0,1,130016,167808,36,0,0,0,0,1,130016,186704,37,0,0,0,0,1,35520,7168,38,0,0,0,0,1,35520,5441);';
  rx_callback(sMessage:=sSimMsg);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimExit" Id="{c590e3ca-ebac-4c15-8972-ce647131e202}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD SimExit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bSimEnable THEN RETURN; END_IF

IF    _nSimMode = 0 THEN
  ;  // no action
ELSIF _nSimMode = 1 THEN
  nFrameNr := 0;
ELSIF _nSimMode = 2 THEN
  ;  // no action
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimulateCamera" Id="{9e193b63-6811-4202-849e-bbfcb100f725}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[(*
  External camera simulation script. 
  Simulates the line camera. Opens a TcpIp server where the the linecam plc client can conect to...
*)
METHOD SimulateCamera
VAR_INST
  rfTrig_En : RF_TRIG;
  tOnFrame  : TON;
END_VAR
VAR
  ams_host : STRING;
  ams_port : UINT;
  cmd : STRING;
  
  tFrameTime : TIME;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _nSimMode <> 1 THEN RETURN; END_IF   // only cam simulation

// simulation enable / disable
rfTrig_En(CLK:=_bSimulate);
IF rfTrig_En.RT THEN 
  // --- start simulation -----
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='Start CamSimulation');

  fbScriptCamSim.Init(sScriptDir:=F_Concat2(_aCamSimScriptPath, 'Tools\CameraTest\'));
  fbScriptCamSim.sStartScriptName := 'Start.bat';
  (* Script parameter:
    parser.add_argument("ams_host", help="AmsNetId of host system")
    parser.add_argument("ams_port", help="AmsPort of host system", type=int)
    parser.add_argument("plc_path", help="plc interface (base) path")
    parser.add_argument("cam_ip", help="camera ip address")
    parser.add_argument("cam_port", help="camera port")
    parser.add_argument("--sim_mode", help="simulation enabled", type=bool)
  *)
  // build cmd line string dynamically 
  ams_host := '';
  ams_port := TwinCAT_SystemInfoVarList._AppInfo.AdsPort; 
  cmd := F_Concat7(ams_host,' ',TO_STRING(ams_port),' ',THIS^.InstanceName,' ',F_Concat3('127.0.0.1',' ',TO_STRING(5030)));
  fbScriptCamSim.Start(cmd);
  
ELSIF rfTrig_En.FT THEN 
  // --- stop/exit simulation ------
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='Stop CamSimulation');
  // stop script
  fbScriptCamSim.Stop(nPID := THIS^.nScriptPID);
END_IF

// --- run script command ------
IF NOT fbScriptCamSim.bBusy THEN 
  IF fbScriptCamSim.bError THEN //Launch error
    LogError(F_Concat2('Script error=', TO_STRING(fbScriptCamSim.nErrId)));
  ELSE //Launch done
    ;
  END_IF
END_IF

// --- script live interface -------
IF _bCamStarted THEN
  IF tOnFrame.Q THEN
    nFrameNr := nFrameNr + 1; // demand next frame
	END_IF
  tFrameTime := REAL_TO_TIME(((84.6667 / 1_000_000) * 0.5)*1000*1024);  // 1024px @300dpi with speed 0.5m/s
  tOnFrame(IN:=NOT tOnFrame.Q, PT:=tFrameTime);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimulatePoints" Id="{497de848-0bbb-4608-8fd6-c3ae48b03141}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[(*
  Simulate camera points.
*)
METHOD SimulatePoints : BOOL
VAR
  fbTonTimer     : TON;
  nCounter       : UDINT;
  nGridHeight    : UDINT;
  nIndex         : UDINT;
  nOffsetY       : UDINT;
END_VAR
VAR CONSTANT
  nFrameSize     : UDINT := 2048;
  nMarksPerFrame : UDINT := 4;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nNbMarksTeach := nMarksPerFrame * TO_UDINT((SEL(fSubstrateLength<>0, 5*nFrameSize, DINT_TO_UDINT(F_MeterToSubPixel(fPosMeter:=fSubstrateLength, fResoSubPx:=_nPrintUnitResolution)))) / nFrameSize);
nGridHeight := SEL(fSubstrateWidth<>0, 200, DINT_TO_UDINT(F_MeterToSubPixel(fPosMeter:=fSubstrateWidth, fResoSubPx:=_nPrintUnitResolution))/nMarksPerFrame);
_bTeachOk := TRUE;

(*Test points*)
nNbMarks := nNbMarksTeach;
nOffsetY := (_nPrintUnitWidthNormal-TO_UDINT(F_MeterToSubPixel(fPosMeter:=_fImageWidth, fResoSubPx:=_nPrintUnitResolution)))/2;

FOR nCounter := 0 TO nNbMarksTeach/nMarksPerFrame - 1 DO    // col
  FOR nIndex := 0 TO nMarksPerFrame-1 DO  // row
    // create point
    stCamPoint := getSimCamPoint(
      fOffsetMin:=-5.0,
      fOffsetMax:=5.0,
      fXMin:=nCounter*nFrameSize,
      fXMax:=(nCounter+1)*nFrameSize,
      fYMin:=nIndex*nGridHeight+nOffsetY,
      fYMax:=(nIndex+1)*nGridHeight+nOffsetY
    );
    //stCamPoint.dx := nCounter;
    //stCamPoint.dy := 0;
    
    // add to container
    IF _iCameraSink<>0 THEN
      _iCameraSink.AddCamPoint(stCamPoint);
    END_IF;
  END_FOR
END_FOR

nNbMarksScanned := nNbMarksTeach;
_ePossibleMode := E_CameraMode.Live;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimUpdate" Id="{9dd7039c-acb3-4c79-a1d4-b41a588914a2}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD SimUpdate : BOOL
VAR_INST
  rTrigCamTriggered : R_TRIG;
  sSimMsg          : CalmarCompTcpIp.ST_TcpMsg;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_rfTrigSim(CLK:=_bSimulate);
IF _rfTrigSim.RT THEN    SimEnter();
ELSIF _rfTrigSim.FT THEN SimExit(); END_IF

_tStartSim();

IF NOT _bSimulate THEN RETURN; END_IF

rTrigCamTriggered(CLK:=_tStartSim.Q);                 // generate rising edge trigger
IF _tStartSim.Q THEN _tStartSim(IN:=FALSE); END_IF   // reset start trigger timer

IF    _nSimMode = 0 THEN
  // direct points stream of all points in trigger
  IF rTrigCamTriggered.Q THEN
     SimulatePoints();
  END_IF
ELSIF _nSimMode = 1 THEN
  // use external camera simulation script
  SimulateCamera();
ELSIF _nSimMode = 2 THEN
  IF rTrigCamTriggered.Q THEN
    // send directly some messages
    sSimMsg.sMessage:='<position(110,A,5,1,125,0,0,0,0,1,12196,9766,137,0,0,0,0,1,69013,9660,149,0,0,0,0,1,135374,9496,161,0,0,0,0,1,40589,9699,163,0,0,0,0,1,116414,9527);';
    rx_callback(sMessage:=sSimMsg);
    sSimMsg.sMessage:='<position(110,A,3,2,126,0,0,0,0,1,11602,28300,138,0,0,0,0,1,68917,28190,150,0,0,0,0,1,136214,27951);';
    // also posible: sSimMsg.sMessage:='<position(110,A,3,2,126,0,0,0,0,1,11602,28300,138,0,0,0,0,1,68917,28190,150,0,0,0,0,1,136214,27951);<position(110,A,0,-1);';
    rx_callback(sMessage:=sSimMsg);
    sSimMsg.sMessage:='<position(110,A,0,-1);';
    rx_callback(sMessage:=sSimMsg);
  END_IF
END_IF


tx_test();]]></ST>
      </Implementation>
    </Method>
    <Property Name="sName" Id="{8732dc14-ed00-4285-9af6-4af340e6ec81}">
      <Declaration><![CDATA[{attribute 'monitoring':='variable'}
PROPERTY sName : STRING
]]></Declaration>
      <Get Name="Get" Id="{fdcd6ceb-8c6b-44dc-986a-bf654cc053d4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sName := 'LineCam Base';]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="sortPoints" Id="{f4e1964a-0fff-406d-bc2b-3f33f82b3c30}">
      <Declaration><![CDATA[(*
  Sort sCameraPoints list with ascending [.id] 
*)
METHOD sortPoints
VAR
  i, k : UDINT;
  tmpPoint : ST_CameraPoint;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// sort array (increasing id)
FOR i := 1 TO nNbMarksTeach DO
  FOR k := 1 TO nNbMarksTeach-1 DO
    IF sCameraPoints[k].id > sCameraPoints[k+1].id THEN
      tmpPoint := sCameraPoints[k+1];
      sCameraPoints[k+1] := sCameraPoints[k];
      sCameraPoints[k] := tmpPoint;
    END_IF
	END_FOR
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="tx_test" Id="{810b87b8-cc78-4799-aab9-b76d18a6e434}" FolderPath="I_Simulation\">
      <Declaration><![CDATA[METHOD PRIVATE tx_test : BOOL
VAR_INPUT
END_VAR
VAR_INST
  _sTestTxMsg               : T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _pFbTcpIpClient = 0 THEN RETURN; END_IF

// sent a test message to QR
IF _bTestTx THEN
  _sTestTxMsg := F_Concat4('<', sQvTest_Header, sQvTest_Loop, ';');
  _tTimeTx := F_GetCurDcTaskTime64();
  _pFbTcpIpClient^.send(sMessage:=_sTestTxMsg);
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('test_tx sent: ', _sTestTxMsg));
  _bTestTx := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="verifyTeachPoints" Id="{9a37f49f-30ad-4791-a4e2-d705f1057462}">
      <Declaration><![CDATA[(*
  Check teach points for validy and quality.
*)
METHOD verifyTeachPoints : BOOL
VAR
  lCtr, lErrCtr : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF _fFrameLength <> 0 THEN
  nNumFrames := LIMIT(1, TO_UDINT(FC_LREAL_TO_DINT((fImageLength / _fFrameLength) + 1, ADR(lErrCtr))), GVL_Camera.cMaxNbSectors); 
END_IF
bNotAllFramesContainTeachPoints := FALSE;
FOR lCtr := 1 TO nNumFrames DO
  IF nNumPointsPerSectorT[lCtr] = 0 THEN
    bNotAllFramesContainTeachPoints := TRUE;
	END_IF
END_FOR


bNotEnoughTeachPoints := FALSE;
IF    nNumPointsPerSectorT[1] < 2  THEN _ePossibleMode := E_CameraMode.NoCorrection; bNotEnoughTeachPoints := TRUE; //< 2 points in first frame
ELSIF nNumPointsPerSectorT[1] <= 2 THEN _ePossibleMode := E_CameraMode.XYR;          bNotEnoughTeachPoints := TRUE; //< 3 points in first frame
ELSE
  _ePossibleMode := E_CameraMode.Live;
END_IF


// teach is valid
_bTeachOk       := TRUE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_LineCamera">
      <LineId Id="2651" Count="31" />
      <LineId Id="2807" Count="0" />
      <LineId Id="2684" Count="2" />
      <LineId Id="2376" Count="0" />
      <LineId Id="2924" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.binarySearch">
      <LineId Id="9" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.bSimEnable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.bSimEnable.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.calcTeachPoints">
      <LineId Id="325" Count="0" />
      <LineId Id="419" Count="0" />
      <LineId Id="416" Count="1" />
      <LineId Id="326" Count="4" />
      <LineId Id="420" Count="0" />
      <LineId Id="403" Count="0" />
      <LineId Id="425" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="421" Count="0" />
      <LineId Id="331" Count="33" />
      <LineId Id="429" Count="16" />
      <LineId Id="365" Count="0" />
      <LineId Id="379" Count="3" />
      <LineId Id="423" Count="1" />
      <LineId Id="383" Count="3" />
      <LineId Id="412" Count="0" />
      <LineId Id="426" Count="2" />
      <LineId Id="415" Count="0" />
      <LineId Id="387" Count="3" />
      <LineId Id="118" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.CamTrigger">
      <LineId Id="20" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.CamTriggerDone">
      <LineId Id="12" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.eCameraMode.Get">
      <LineId Id="23" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.eDeviceType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.GetCamStatus">
      <LineId Id="33" Count="3" />
      <LineId Id="49" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.getPointIndex">
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.getSimCamPoint">
      <LineId Id="15" Count="8" />
      <LineId Id="45" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.InitLineCamera">
      <LineId Id="29" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="53" Count="3" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.InitSimulation">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.mJobStart">
      <LineId Id="6" Count="1" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_callback">
      <LineId Id="2519" Count="43" />
      <LineId Id="2564" Count="6" />
      <LineId Id="2644" Count="0" />
      <LineId Id="2571" Count="35" />
      <LineId Id="2662" Count="0" />
      <LineId Id="2610" Count="17" />
      <LineId Id="1013" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_DeleteMsgPart">
      <LineId Id="10" Count="6" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_ErrorMsg">
      <LineId Id="23" Count="13" />
      <LineId Id="66" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_ParseHeader">
      <LineId Id="210" Count="1" />
      <LineId Id="37" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="21" Count="5" />
      <LineId Id="157" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="46" Count="3" />
      <LineId Id="66" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="83" Count="9" />
      <LineId Id="154" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="115" Count="6" />
      <LineId Id="155" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="239" Count="1" />
      <LineId Id="261" Count="2" />
      <LineId Id="260" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="212" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_ParsePoint">
      <LineId Id="849" Count="3" />
      <LineId Id="1010" Count="0" />
      <LineId Id="854" Count="1" />
      <LineId Id="862" Count="119" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.rx_TestMsg">
      <LineId Id="20" Count="5" />
      <LineId Id="96" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="97" Count="0" />
      <LineId Id="28" Count="22" />
      <LineId Id="82" Count="0" />
      <LineId Id="52" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.saveAuswertungPoint">
      <LineId Id="5" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="147" Count="1" />
      <LineId Id="166" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="15" Count="24" />
      <LineId Id="54" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="113" Count="2" />
      <LineId Id="63" Count="1" />
      <LineId Id="116" Count="1" />
      <LineId Id="69" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="120" Count="4" />
      <LineId Id="119" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="135" Count="1" />
      <LineId Id="150" Count="1" />
      <LineId Id="134" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.saveTeachPoint">
      <LineId Id="41" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="116" Count="1" />
      <LineId Id="120" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.setCameraMode">
      <LineId Id="11" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.SimEnter">
      <LineId Id="33" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="45" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="13" Count="9" />
      <LineId Id="51" Count="1" />
      <LineId Id="23" Count="1" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.SimExit">
      <LineId Id="11" Count="1" />
      <LineId Id="6" Count="4" />
      <LineId Id="13" Count="0" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.SimulateCamera">
      <LineId Id="78" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="51" Count="6" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="7" Count="2" />
      <LineId Id="11" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="87" Count="2" />
      <LineId Id="92" Count="0" />
      <LineId Id="83" Count="1" />
    </LineIds>
    <LineIds Name="FB_LineCamera.SimulatePoints">
      <LineId Id="380" Count="12" />
      <LineId Id="407" Count="0" />
      <LineId Id="394" Count="4" />
      <LineId Id="408" Count="1" />
      <LineId Id="399" Count="7" />
      <LineId Id="2" Count="0" />
      <LineId Id="424" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.SimUpdate">
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="48" Count="1" />
      <LineId Id="22" Count="3" />
      <LineId Id="50" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="34" Count="1" />
      <LineId Id="56" Count="1" />
      <LineId Id="37" Count="2" />
      <LineId Id="51" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.sName.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.sortPoints">
      <LineId Id="24" Count="2" />
      <LineId Id="37" Count="0" />
      <LineId Id="29" Count="3" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_LineCamera.tx_test">
      <LineId Id="5" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="1" />
    </LineIds>
    <LineIds Name="FB_LineCamera.verifyTeachPoints">
      <LineId Id="90" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="49" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="50" Count="1" />
      <LineId Id="48" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
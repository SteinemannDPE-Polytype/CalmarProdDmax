<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_PrintModule_Maxliner" Id="{52a578ff-afc6-4f04-988e-6fc06fc30b55}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  A DVT PrintModule (DEU, DSU, WEU).
*)
FUNCTION_BLOCK FB_PrintModule_Maxliner EXTENDS T_NamedBase IMPLEMENTS I_Sim, I_PositionEvent
VAR_INPUT
  // encoder input --> directly mapped into FB_PrintPosition 
  // machine state by pointer in init()
  // external start pos interface by pointer in init()
  fPrintOffsetX           : LREAL;   // [m] external configurative offsets to PM (PU)
  fPrintOffsetY           : LREAL;   // [m] external configurative offsets to PM (PU)

  fPUPlate1_Temperature   : LREAL;  // PU Plate1 temperature
END_VAR

VAR
  //config

  // - references
  _pModuleSetup           : POINTER TO ST_CassetteSetup;
  _iPrintGlobal           : I_PrintGlobal;        // master module (setting, position, global stuff, ...)
  _iPrintPosition         : I_PrintPosition;      // module's position
  _iStartPos              : I_StartPosDetect;     // module's start position detect
  _iModule                : I_Module;             // module's system status
  _pModuleMachineState    : POINTER TO ST_ModuleMachineInterface_IN;   // machine interface-print states
  _pModuleMachineFeedback : POINTER TO ST_ModuleMachineInterface_OUT;  // machine interface-print feedback
    
  // status
  bInit                   : BOOL;   // initialized
  bSelectedForPrint       : BOOL;   // selected for printing
  bReadyForPrinting       : BOOL;   // Module ready for printing
  bHardwareHold           : BOOL;   // hw hold
  _bGridLimited           : BOOL;   // calculated grid was limited before sending
  
  // instances
  fbPrintPosition         : FB_PrintPositionDmax;   // a position per pm (external encoder wheel)

  fbCTTracker             : FB_CTTracker;
  fbParamMediator         : FB_DefGridParamMediator;
  fbWorkerPython          : FB_WorkerDefGrid_Python;
  fbWorkerCamera          : FB_WorkerDefGrid_Camera;
  fbWorkerDeformation     : FB_WorkerDefGrid_Deformation;
  fbWorkerPrint           : ARRAY[1..GVL_Maxliner.nC_MaxWorkerPrintPerPm] OF FB_WorkerDefGrid_Print;
  
  _pAdsSa                 : POINTER TO FB_ADS_DVTSHEETALIGNMENT; // sheet alignement ads
  fbAdsPm                 : FB_ADS_PM;      // PM -  Print Module ADS
  fbAdsPg                 : ARRAY[1..GVL_Maxliner.nC_MaxWorkerPrintPerPm] OF FB_ADS_PG;  // PG - PrintGroup ADS
  
  // hw (references only for now) ------
  // - pc
  _pPc                    : ARRAY[1..GVL_Maxliner.nC_MaxPcPerPm] OF POINTER TO FB_PC;
  _nPc                    : UDINT;  // number of PC in module
  _nPcToWorker_Mapping    : ARRAY[1..GVL_Maxliner.nC_MaxPcPerPm] OF UDINT;   // Mapping of PC to worker  
  _nPcToPgAbsoluteIdx     : ARRAY[1..GVL_Maxliner.nC_MaxPcPerPm] OF UDINT;   // Mapping of PC to absolute PG index
  // - ph
  _pPh                    : ARRAY[1..GVL_Maxliner.nC_MaxPhPerPm] OF POINTER TO FB_PH;
  _nPh                    : UDINT;  // number of PH in module
  _nPhToWorker_Mapping    : ARRAY[1..GVL_Maxliner.nC_MaxPhPerPm] OF UDINT;  // Mapping of PH to worker
  _nPhToPc_Mapping        : ARRAY[1..GVL_Maxliner.nC_MaxPhPerPm] OF UDINT;  // Mapping of PH to PC
  _nPhToPcCh_Mapping      : ARRAY[1..GVL_Maxliner.nC_MaxPhPerPm] OF UDINT;  // Mapping of PH to PC channel
  _nPhToPgAbsoluteIdx     : ARRAY[1..GVL_Maxliner.nC_MaxPhPerPm] OF UDINT;  // Mapping of PH to absolute PG index
  
  // helper
  nCtr                    : UDINT;
  nYShift_PcRamCenter     : UDINT;     // y-shift for centered image in CB RAM [px]
  fSpeed, fSpeedMpMin     : LREAL;
  bSpeedReachedForPrinting: BOOL;      // Speed for printing reached
  nPos_SubPx, nPos_Px     : DINT;
  nPos_SubPx_mem          : DINT;
  fPos_um                 : LREAL;
  nTrackPosMain           : DINT;      // tracker attach position - module position relative to pos reference in main tracker [m]

  bHwSyncCmd              : BOOL;
  sCamGridSettings        : ST_CameraGridSettings;
  bOnePgActive            : BOOL;

  // sync CT trigger with Camera detection
  _bNewCT                 : BOOL;   // a new ct is received to be treated
  _iNewCT                 : I_CT;   // new ct to be treated
  _bNewStartPosX0         : BOOL;   // a new startpos detected by cam
  _nNewStartPosX0         : DINT;   // new startpos X0 deteced by cam

  fbFineAlignement        : FB_FineAlignement;     // additional grid corrections, PU Deformation/correction (4p, banana, ...)

  // messaging
  fb_MsgQueue             : FB_MSG_QUEUE;                 (*Message queue*)
  fb_MsgHandler           : FB_MSG_HANDLER;               (*Message handler*)
  sL_MsgConfig            : ST_MSG_CONFIG;                (*Message config*)
//fbMsg                   : ARRAY [1..nC_NumMsg] OF FB_MESSAGE;  (*Messages*)
  
  // simulation
  fbSim                   : FB_Sim;

  // view
  fbView                  : FB_PrintModule_Maxliner_View;    // additional controls for print module visus

  // test
  bTestMsg : BOOL;      // activate message test
END_VAR

VAR PERSISTENT
  _fPmDistToPrev          : LREAL;                 // [m] distance to previous PM (in main domain)
  _fPmMainTrackPos        : LREAL;                 // [m] used distance to master reference position (in main tracker)
END_VAR

VAR CONSTANT
  nC_NumMsg               : UDINT := 0;            // number of internal messages
  fC_HeadOffsetPlate      : LREAL := 0.000_2;      // Head offset to base plate [m] (mechanical)
  fC_MinimalProductionSpeed_in_MpMin: LREAL := 5.0;    // [m/min]
  fC_FormatLengthTolerance : LREAL := 100.0;       // [px] tolerance of substrate length job - machine config 
  nC_StopReadyTimeout     : TIME := T#10S;         // Synced stopping of printing, max. timeout to wait for printing end
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bInit THEN RETURN; END_IF

// position
fbPrintPosition.fEnoderResolution := _pModuleMachineState^.fEncoderResolution;    // encoder resolution from machine
fbPrintPosition();

// -------------------------
// StartTrigger evaluation -> apply new CT to Tracking (created from CTM externally)
// Synchronize CT (EvPos) received from CTManger (Main) to the local StartTrigger detection and positioning
// -- reset triggers if not active
IF NOT bReadyForPrinting THEN
  _bNewCT := 0; _bNewStartPosX0 := 0;
END_IF
// -- new StartTrigger (X0)
IF bReadyForPrinting AND _iStartPos.bStartTrig AND _iStartPos.bValid THEN
  // buffer/save new start trigger
  _bNewStartPosX0 := TRUE;
  _nNewStartPosX0 := _iStartPos.nStartPositionX0;      // save detected start position for next CT to be applied to this module¨
  
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat3(
    F_Concat2(_pModuleSetup^.aName, ' New StartTrigger detected:'),
    F_Concat2(' at position X0:', TO_STRING(_nNewStartPosX0)),
    F_Concat2(' PM is now at: ', TO_STRING(fbPrintPosition.getPosition())),
  ));
  
  IF _bNewCT THEN   // we have an attached CT
      LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat3(
      F_Concat2(_pModuleSetup^.aName, ' Track NewCT:'),
      F_Concat2(' internal (print)Pos X0:', TO_STRING(_nNewStartPosX0)),
      F_Concat2(' with CT:', _iNewCT.print(0))
    ));
    
    _iNewCT.nPosPrint_X0 := _nNewStartPosX0;                            // set print pos to new dected in this module position domain
    fbCTTracker.RegisterCT(iCT := _iNewCT, nX0 := _nNewStartPosX0);     // register ct for tracking in modules position and tracking system
  ELSE
    // spurious trigger (CTs not yet arrived at PMx, but receive some StartTriggers
    LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat3('StartTrigger at Pos X0:', TO_STRING(_nNewStartPosX0), ' but no CT received'));
	END_IF
  
  // reset internals (saved triggers)
  _bNewCT := FALSE; _iNewCT := 0; 
  _bNewStartPosX0 := FALSE;
END_IF

// positioning
// - get position 
nPos_SubPx := _iPrintPosition.getPosition(nPosition_px=>nPos_Px, fPosition_um=>fPos_um);
// (disabled) nPos_SubPx := nPos_SubPx_mem := SEL(bReadyForPrinting AND _iPrintPosition.bMoving, nPos_SubPx_mem, nPos_SubPx);   // security measure (jetting when not really moving or not in position
// - get speed
fSpeed := _iPrintPosition.getSpeed(fSpeedMpMin=>fSpeedMpMin);

// update distance from machine
_fPmDistToPrev := _pModuleMachineState^.fDistanceToPrevModule;

// enable, control, release signals
//   engaged -> selected and prepared for production
//   printActivated -> machine & axis position ready for printing
//   InitInPrintPosition -> module in pos to allow printing
bSelectedForPrint        := fbAdsPm.bEnable AND _pModuleMachineState^.bEngaged;
bSpeedReachedForPrinting := (fSpeedMpMin >= fC_MinimalProductionSpeed_in_MpMin);
// ready for printing (enable detection)
bReadyForPrinting        :=      bSelectedForPrint                                // selected and ready for production (from machine)
                            AND _pModuleMachineState^.bPrintActivated             // machine & axis ready for printing
                            AND _pModuleMachineState^.bUnitInPrintPosition        // module in printing position -> allowed to print
                            AND bSpeedReachedForPrinting                          // speed bigger than min speed for printing
                            AND _pModuleMachineState^.bTargetSpeedReached         // do not evaluate marks while machine ramping up  
                            AND NOT _pModuleMachineState^.bStopRequest            // do not evaluate marks while machine is stopping
                            AND NOT _pModuleMachineState^.bEStop
                            AND NOT _pModuleMachineState^.bSleep;
bHardwareHold            := NOT bSpeedReachedForPrinting OR 
                            NOT _pModuleMachineState^.bPrintActivated OR 
                            NOT _pModuleMachineState^.bUnitInPrintPosition OR 
                                _pModuleMachineState^.bFastStopRequest;
bHwSyncCmd               := checkHwSyncRequest();                                 // sync trigger generation

// pos for attach in main tracker
nTrackPosMain := F_MeterToSubPixel(fPosMeter:=_fPmMainTrackPos, fResoSubPx:=_iPrintPosition.fPrintResolution*_iPrintPosition.fSubPxResolution); 
// run tracker
fbCTTracker(nPos:=nPos_SubPx);


// call hardware
(* -- PC PrintController*)
FOR nCtr := 1 TO _nPc DO
  IF _pPc[nCtr] <> 0 THEN
    _pPc[nCtr]^.sI_SystemCmd.bSleep := _pModuleMachineState^.bSleep;  // from if to module (machine)
    _pPc[nCtr]^.sI_SystemCmd.bEStop := _pModuleMachineState^.bEStop;  // from if to module (machine)
    _pPc[nCtr]^.sI_SystemCmd.bAirNotOk := FALSE;
    _pPc[nCtr]^();
  END_IF
END_FOR

(* -- PH PrintHead*)
FOR nCtr := 1 TO _nPh DO
  IF _pPh[nCtr] <> 0 THEN
    ; // called in PC.update()->pPh[nCtr]^();
  END_IF
END_FOR


// Worker
// - Camera
fbWorkerCamera.bWorkerEnable := fbAdsPm.bEnable AND bOnePgActive;
sCamGridSettings := fbWorkerCamera.sCameraGridSettings;
// - Deformation
fbWorkerDeformation.bWorkerEnable := fbAdsPm.bEnable AND bOnePgActive AND sCamGridSettings.eDeformationType > E_DeformationType.NoDeformation;

// - Print
// - fill I_SubSystem correctly from all workers
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  fbWorkerPrint[nCtr].bWorkerEnable := fbAdsPm.bEnable AND fbWorkerPrint[nCtr]._pAdsPg^.bEnable;
  //fbWorkerPrint[nCtr].bWorkerPrintEnable := _pModuleMachineState^.bPrintActivated;
  fbWorkerPrint[nCtr](
    nEncoderPos           := nPos_SubPx,
    fMasterSpeed          := fSpeed,
    bHardwareSync         := bHwSyncCmd,
    bHardwareHold         := bHardwareHold,
  //nPhDepth              := _pModuleSetup^.pSetupPrint^.sPHType.iC_Ph_Depth,
  //bFastStopRequest      := _pModuleMachineState^.bFastStopRequest,
  //bPrintStopRequest     := _pModuleMachineState^.bStopRequest,
                            // Print StartPosition Distance to detected X0 of CT
    fPrintStartOffset     :=   fPrintOffsetX                                    // NOTE: dynamic corrections done in Worker (dropSpeedComp / global grid dx / other point corrections))
                             - TO_LREAL(fbAdsPm.nGeneralShiftX) / 1_000_000     // ! negative direction to match PUC UI => change requested by STAG (14.08.2024)
                             + TO_LREAL(fbAdsPg[nCtr].nPositionX) / 1_000_000,
    fPrintYOffset         := LIMIT(
                              0,
                                F_SubPixelToMeter(TO_DINT(nYShift_PcRamCenter), _iPrintPosition.fPrintResolution)              // y-offset for centered image in ph
                                + fPrintOffsetY
                                - TO_LREAL(fbAdsPm.nGeneralShiftY) / 1_000_000    // ! negative direction to match PUC UI => change requested by STAG (16.12.2024)
                                + TO_LREAL(fbAdsPg[nCtr].nPositionY) / 1_000_000
                                + _pModuleMachineState^.fLateralRegister  // lateral register from machine
                              ,2*F_SubPixelToMeter(TO_DINT(nYShift_PcRamCenter), _iPrintPosition.fPrintResolution)
                            ),
    fPUElevation          := _pModuleMachineFeedback^.fHeadGap, // + fC_HeadOffsetPlate,
//    bError                => ,
//    nError                => ,
  );
END_FOR

// collect printWorker status
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  IF fbWorkerPrint[nCtr].bWorkerEnable THEN
    _bGridLimited := fbWorkerPrint[nCtr]._bGridWasLimited OR _bGridLimited; 
	END_IF
END_FOR

// One PG (printWorker) active
bOnePgActive := FALSE;
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO 
  IF fbAdsPg[nCtr].bEnable THEN bOnePgActive := TRUE; END_IF 
END_FOR

  
// machine interface outputs
_pModuleMachineFeedback^.bMoving           := bSpeedReachedForPrinting;
_pModuleMachineFeedback^.fSpeed            := fSpeed;
_pModuleMachineFeedback^.fPosition         := fPos_um / 1_000_000;
_pModuleMachineFeedback^.bSpeedExeeded     := checkSpeed(fSpeed:=fSpeed, fMaxSpeed => _pModuleMachineFeedback^.fMaxSpeed);
_pModuleMachineFeedback^.bLengthMismatch   := checkFormatLength();
_pModuleMachineFeedback^.bStopReady        := checkReadyForStop(bStopRequestSync:=_pModuleMachineState^.bStopRequest);
_pModuleMachineFeedback^.fHeadGap          := _pAdsSa^.fHeadGap / 1000;  // [mm] -> [m]
_pModuleMachineFeedback^.fInkQuantity      := getInkQuantity();

(*PU corrections*)
IF GVL_Deformation.bC_UsePUDeformation THEN
  fbFineAlignement.fT_PL1 := fPUPlate1_Temperature;
  fbFineAlignement.fT_PL2 := fPUPlate1_Temperature;  // Plate2 not existing
  fbFineAlignement();
END_IF

// simulation
SimUpdate();

// view
fbView();

// messaging
Messaging();
]]></ST>
    </Implementation>
    <Folder Name="I_PositionEvent" Id="{5e87d86c-ca15-45cb-bada-e6cd68013c28}" />
    <Folder Name="I_Sim" Id="{2a3dfc65-ed3d-4227-8e2b-1968d65b357b}" />
    <Folder Name="Position" Id="{5718c4e9-4d52-45b0-936b-c700f788dd91}" />
    <Folder Name="Simulation" Id="{c5b497ca-a4be-4da0-b220-270447d3c89d}" />
    <Folder Name="Status" Id="{718a2f9d-a4cf-4597-b57e-eee983d7a1a0}" />
    <Property Name="bMoving" Id="{8beb3766-1349-4fa4-90fd-1a3c43cbabd0}" FolderPath="Position\">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY bMoving : BOOL]]></Declaration>
      <Get Name="Get" Id="{264816e8-c8ce-47fa-8ada-ee666e9a1532}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bMoving := _iPrintPosition.bMoving;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="bSelectedForProduction" Id="{8850da90-fa1f-4b86-b332-d996d0887fd5}" FolderPath="Status\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
// module is selected for production (and considered in positioning)
PROPERTY bSelectedForProduction : BOOL]]></Declaration>
      <Get Name="Get" Id="{9394715e-0ecf-45a1-b12c-153db5808447}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSelectedForProduction := bSelectedForPrint;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="bSimEnable" Id="{82bf8e8a-4f7b-4516-8eb3-22395b4ea9c0}" FolderPath="I_Sim\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
(*Simulation is enabled set/get*)
PROPERTY bSimEnable : BOOL
]]></Declaration>
      <Get Name="Get" Id="{3c34f5fc-8834-415a-82e2-f28c826f06b3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSimEnable := fbSim.bSimEnable;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{6fcad1b3-c5f4-4a10-b6b8-0e85db9831a8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fbSim.bSimEnable := bSimEnable;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bSyncCmd" Id="{4670f7fb-ef10-4698-86c0-891ed8376963}" FolderPath="Position\">
      <Declaration><![CDATA[(* 
  Hardware sync request.
*)
PROPERTY bSyncCmd : BOOL]]></Declaration>
      <Get Name="Get" Id="{9152cdf3-8105-483e-8dea-12be5e33a568}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSyncCmd := bHwSyncCmd;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="checkFormatLength" Id="{1bb5bff4-b7f2-4c31-98e2-794d04f47633}">
      <Declaration><![CDATA[// check imagelength vs formatlength
// :returns: TRUE if a mismatch was detected
METHOD PRIVATE checkFormatLength : BOOL
VAR 
  nFormatTolerance : LREAL;
  bOneJobActive    : BOOL;
  i                : UDINT;
  _fImageLength    : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// check config
_fImageLength := 0;
FOR i := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  IF fbWorkerPrint[i]._bEnable THEN
    _fImageLength := fbWorkerPrint[i].fImageLength;
	END_IF
END_FOR

IF _fImageLength = 0 THEN RETURN; END_IF
IF _pModuleMachineState^.fSubstrateLen = 0 THEN RETURN; END_IF
IF bSimEnable THEN RETURN; END_IF  // check ok during simulation

bOneJobActive := FALSE;
FOR i := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  bOneJobActive := bOneJobActive OR fbWorkerPrint[i].bJobActive;
END_FOR
IF NOT bOneJobActive THEN RETURN; END_IF

// compare
nFormatTolerance := fC_FormatLengthTolerance / _pModuleSetup^.pSetupPrint^.nPrintResolution * 0.0254;  // 100 [px] -> [m]
IF nFormatTolerance < ABS(_fImageLength - _pModuleMachineState^.fSubstrateLen) THEN
  checkFormatLength := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkHwSyncRequest" Id="{8a4ab09e-5937-49a0-89a2-a6728496fff7}" FolderPath="Position\">
      <Declaration><![CDATA[METHOD PROTECTED checkHwSyncRequest : BOOL
VAR_INST
  rT_SyncRequest : R_TRIG;
  tSyncDelay     : TON;
END_VAR
VAR_OUTPUT
  bHwSyncReq : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rT_SyncRequest(CLK:=bReadyForPrinting);
IF rT_SyncRequest.Q OR _iPrintPosition.bStarted THEN  // OR rT_JobActive.Q 
  tSyncDelay(IN:=TRUE, PT:=T#2MS);   // a Sync delay to workaround a sync sent to CB while a Start or Prepare Command
END_IF
tSyncDelay(Q=>bHwSyncReq);
IF tSyncDelay.Q THEN 
  tSyncDelay(IN:=FALSE);
END_IF


checkHwSyncRequest := bHwSyncReq;]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkReadyForStop" Id="{6bd4745b-1775-48e3-8375-4e3f7f92c962}">
      <Declaration><![CDATA[METHOD PRIVATE checkReadyForStop : BOOL
VAR_INPUT
  bStopRequestSync : BOOL;
END_VAR
VAR
  i : UDINT;
  bStopReady : BOOL;
END_VAR
VAR_INST
  tOnStoppingSupversion : TON;  // check if it takes too long for stopping print with (synced)stop-request
  rTSupervsion : R_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// check print states
bStopReady := TRUE;
FOR i := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO                        // all worker stopped?
  bStopReady := bStopReady AND NOT fbWorkerPrint[i].bPrintActive;   // stop ready if no print is active
END_FOR

// error handling
// - 
tOnStoppingSupversion(IN:=bStopRequestSync AND NOT bStopReady, PT:=nC_StopReadyTimeout);   // supervision for synchronized stopping the print of module
rTSupervsion(CLK:=bStopRequestSync AND tOnStoppingSupversion.Q);    // 
IF rTSupervsion.Q THEN LogWarning('checkReadyForStop: stopped by timeout (stop ready not received from PM)'); END_IF


// ready if request set and all finished printing (or supervision)
checkReadyForStop := bStopRequestSync AND (bStopReady OR tOnStoppingSupversion.Q);]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkSpeed" Id="{fc07e9a8-d2a3-483b-b84c-91bcfde22ba1}">
      <Declaration><![CDATA[(*
  Checks if current speed is higher than max. speed.
  :return: TRUE if speed exeeds maximum
*)
METHOD PROTECTED checkSpeed : BOOL
VAR_INPUT
  fSpeed : LREAL;       // current speed
END_VAR
VAR_OUTPUT
  fMaxSpeed : LREAL;    // modules max. printing speed
END_VAR
VAR
  f : LREAL;
  i : UDINT;
END_VAR
VAR_INST
  fbSpeedFilterMav : FB_FILTER_MAV;           // Moving average filter
  fMaxSpeedTolerence : LREAL := 1.0/60;       // Allow max. speed to exeed limit + this tolerance 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// disabled
IF NOT fbAdsPm.bEnable OR NOT _pModuleMachineState^.bEngaged THEN 
  checkSpeed := FALSE;
  fMaxSpeed := 0;
  RETURN;
END_IF 


// filter current speed
fbSpeedFilterMav(fI_Input := fSpeed, iI_NbInputs := 32);  (*max iI_NbInputs = 32!*)

// find slowest max. speed
f := 0;
FOR i:=1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  IF fbWorkerPrint[i].bWorkerEnable THEN
    IF fbWorkerPrint[i].fMaxSpeed = 0 THEN
      ; // ignored speed
    ELSIF f = 0 OR f > fbWorkerPrint[i].fMaxSpeed THEN 
      f := fbWorkerPrint[i].fMaxSpeed;
		END_IF
	END_IF
END_FOR

fMaxSpeed := f;   // return max. possible speed

// check if too fast
IF f > 0 AND fbSpeedFilterMav.fO_OutputMav > (f+fMaxSpeedTolerence) THEN 
  checkSpeed := TRUE; // speed exceeded
ELSE
  checkSpeed := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="fDetectToPm" Id="{8698d1bb-b892-4b4a-9b98-4e3403d7e00b}" FolderPath="Position\">
      <Declaration><![CDATA[(*
  Distance between activated StartPosition detection and Pm, if one configured (fDetectToCameraOffset + fCameraToPrintOffset)
  If no StartPos detection = 0
*)
PROPERTY fDetectToPm : LREAL]]></Declaration>
      <Get Name="Get" Id="{d8b15dc6-0e30-4551-afc4-935b7ca703ac}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fDetectToPm := fbWorkerCamera.fDetectToCamOffset + fbWorkerCamera.fCameraToPrintOffset;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="fPmDistToPrev" Id="{c6c6b8bc-f66e-4146-8416-0b6c5e3f3a3c}" FolderPath="Position\">
      <Declaration><![CDATA[// distance to previous print module (on master tracking pos)
PROPERTY fPmDistToPrev : LREAL]]></Declaration>
      <Get Name="Get" Id="{961182bb-3daa-43fc-8d9d-5e3d5cb29232}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fPmDistToPrev := _fPmDistToPrev;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{3dbabcef-7954-4b9c-8fee-1a4729452d57}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fPmDistToPrev := fPmDistToPrev;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="fPmMainTrackPos" Id="{a5bb0101-bf94-4622-99d5-2d33b5f97944}" FolderPath="Position\">
      <Declaration><![CDATA[PROPERTY fPmMainTrackPos : LREAL]]></Declaration>
      <Get Name="Get" Id="{84cdf8ff-7026-4ff7-939a-e3caed27e845}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fPmMainTrackPos := _fPmMainTrackPos;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{2f21bec5-d9c8-4b5c-a5c5-9f95e66f4889}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fPmMainTrackPos := fPmMainTrackPos;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="getInkQuantity" Id="{f9f08309-c65e-49c1-ba66-1788ba0004d4}">
      <Declaration><![CDATA[METHOD getInkQuantity : LREAL
VAR
  nWorker : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR nWorker := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  IF fbWorkerPrint[nWorker].bWorkerEnable THEN    // from first enabled worker (PG)
    getInkQuantity := fbWorkerPrint[nWorker]._pAdsPg^.lInkQuantity;
    EXIT;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{1779a3ce-22a4-4afc-a82c-d9e294ed449b}">
      <Declaration><![CDATA[METHOD Init : BOOL
VAR_INPUT
  pModulesSetup         : POINTER TO ST_CassetteSetup;          // Module Setup Settings
  pAdsSa                : POINTER TO FB_ADS_DVTSHEETALIGNMENT;  // ADS sheet alignement
  pAdsCam               : POINTER TO FB_ADS_CAMERA;             // ADS camera
  pAdsParent            : POINTER TO FB_ADS_Config;             // Parent ADS config reference (Parent ADS block and module ref)

  // config print
  fCycleTime            : LREAL;                // task cycle time in [s]
  fPrintUnitWidth       : LREAL;                // PrintUnit width mechanical [m]
  // references
  iModule               : I_Module;             // system status interface (for sleep, estop, ...), may shadow states from machine inputs
  iPrintGlobal          : I_PrintGlobal;        // interface for module to master (main) communication
  pMachineInputs        : POINTER TO ST_ModuleMachineInterface_IN;
  pMachineOutputs       : POINTER TO ST_ModuleMachineInterface_OUT;

  iStartPos             : I_StartPosDetect;     // module's start position detect
END_VAR

VAR
  nCtr : UDINT;
  sMode : ST_SimModeDef;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF         pModulesSetup = 0 
   OR_ELSE pAdsSa = 0 
   OR_ELSE pAdsCam = 0 
   OR_ELSE pAdsParent = 0 
   OR_ELSE pMachineInputs = 0 
   OR_ELSE pMachineOutputs = 0 
   OR_ELSE iPrintGlobal = 0 
THEN
  LogError('init(): Invalid parameter');
  RETURN;
END_IF

// save config
_pModuleSetup := pModulesSetup;
_pAdsSa := pAdsSa;
_iPrintGlobal := iPrintGlobal;
_iModule := iModule;
_pModuleMachineState := pMachineInputs;
_pModuleMachineFeedback := pMachineOutputs;
nYShift_PcRamCenter := _pModuleSetup^.pSetupPrint^.nPcYShiftCenterRam;

// -- Sheet/Camera
_iStartPos := iStartPos;  // select start position detection


// init & setup hw and module linking
SetupHw();

// ADS config and mapping
InitAds(pAdsParent:=pAdsParent);

// position
fbPrintPosition.Init(fPrintResolution := pModulesSetup^.pSetupPrint^.nPrintResolution, fSubPxResolution := pModulesSetup^.pSetupPrint^.nSubPixelResolution, fTaskCycleTime := fCycleTime);
_iPrintPosition := fbPrintPosition;  // select reference position

// cttracker
fbCTTracker.Init(aName:=F_Concat2('Tracker of ', pModulesSetup^.aName), aUnit:='SubPx', bAutoRemoveAfterLastEvPos:=TRUE);

// Worker
// -- parameter mediator
fbParamMediator.init(pCamWorker:=ADR(fbWorkerCamera), pDefWorker:=ADR(fbWorkerDeformation));

// -- Worker Python
fbWorkerPython.Init(pMsgConfig:=ADR(sL_MsgConfig), fPrintResolution:=_iPrintPosition.fPrintResolution, fSubPxResolution:=_iPrintPosition.fSubPxResolution, bParallelCT:=TRUE);
fbWorkerPython.InitWorkerPython(aScriptPath:=F_Concat2(GVL_Maxliner.aC_PlcProjectCfgPath, 'Tools\Deformation\'), iDefGridParamMediator:=fbParamMediator);
fbWorkerPython.reg();
fbCTTracker.RegisterTrackPos(iPositionEvent := fbWorkerPython);
iPrintGlobal.registerPuStatusClient(sClient := fbWorkerPython);

// -- Worker camera
fbWorkerCamera.Init(pMsgConfig:=ADR(sL_MsgConfig), fPrintResolution:=_iPrintPosition.fPrintResolution, fSubPxResolution:=_iPrintPosition.fSubPxResolution, bParallelCT:=TRUE);
fbWorkerCamera.InitWorkerCamera(pAdsIf:=pAdsCam, iDefGridParamMediator:=fbParamMediator, fFeatureGrid:=256, fPrintUnitWidth:=fPrintUnitWidth);
fbWorkerCamera.reg();
fbCTTracker.RegisterTrackPos(iPositionEvent := fbWorkerCamera);
iPrintGlobal.registerPuStatusClient(sClient := fbWorkerCamera);

// -- Worker deformation
fbWorkerDeformation.Init(pMsgConfig:=ADR(sL_MsgConfig), fPrintResolution:=_iPrintPosition.fPrintResolution, fSubPxResolution:=_iPrintPosition.fSubPxResolution, bParallelCT:=TRUE);
fbWorkerDeformation.InitWorkerDeformation(nPrintUnitWidth:=TO_UDINT(F_MeterToSubPixel(fPosMeter:=fPrintUnitWidth, fResoSubPx:=_iPrintPosition.fPrintResolution)), iDefGridParamMediator:=fbParamMediator);
fbWorkerDeformation.reg();
fbCTTracker.RegisterTrackPos(iPositionEvent := fbWorkerDeformation);
iPrintGlobal.registerPuStatusClient(sClient := fbWorkerDeformation);

// -- Worker print
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  fbWorkerPrint[nCtr].Init(
    fPrintResolution:=_iPrintPosition.fPrintResolution,
    fSubPxResolution:=_iPrintPosition.fSubPxResolution,
    pMsgConfig:=ADR(sL_MsgConfig),
    bParallelCT:=TRUE
  );
  fbWorkerPrint[nCtr].InitWorkerPrint(
    pAdsPg                := ADR(fbAdsPg[nCtr]),
    iDefGridParamMediator := fbParamMediator,
    fPrintUnitWidth       := fPrintUnitWidth,
    fLimitCorrectionX     := 1000,
    fLimitCorrectionY     := nYShift_PcRamCenter - 1
  );
  fbWorkerPrint[nCtr].reg();
  fbCTTracker.RegisterTrackPos(iPositionEvent := fbWorkerPrint[nCtr]);
  iPrintGlobal.registerPuSubystem(iSubSys := fbWorkerPrint[nCtr]);
END_FOR

// additional grid point corrections
fbFineAlignement.init(pAdsCam := pAdsCam, fPxReso := _iPrintPosition.fPrintResolution, fPuWidth := fPrintUnitWidth);
// - register them to workers
(*Register not existing yet
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  fbWorkerPrint[nCtr].RegisterGridCorrection(iGridCorrection := fbFineAlignement);
END_FOR *)

fbView.init(pModule := THIS, pPositioning := ADR(fbPrintPosition));

(*Messaging*)
sL_MsgConfig.bI_Enable       := TRUE;
sL_MsgConfig.pI_FbMsgHandler := ADR(fb_MsgHandler);
fb_MsgHandler.pI_MsgQueue    := ADR(fb_MsgQueue);
fb_MsgQueue.pI_MsgInterface  := fbAdsPm.pMsgInterface;
fb_MsgQueue.cI_MaxElement    := TO_INT(SIZEOF(fbAdsPm.pMsgInterface^.sO_MsgBuffer)/SIZEOF(ST_ADS_MSG));

(*Messages*)
(*
FOR nCtr := 1 TO nC_NumMsg DO
  fbMsg[nCtr].pI_MsgConfig   := ADR(sL_MsgConfig);
  fbMsg[nCtr].iI_MsgLocation := 1;
END_FOR;

fbMsg[ 1].iI_MsgNumber       := ;     // mark detection error
*)
Init := bInit := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitAds" Id="{cf2368c2-4e15-44bf-9a38-878f9b8d2b3e}">
      <Declaration><![CDATA[// ADS Configuration of interface 
// ADS Block Mapping of Module
METHOD PROTECTED InitAds
VAR_INPUT
  pAdsParent  : POINTER TO FB_ADS_Config;             // Parent ADS config reference (Parent ADS block and module ref)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ADS Mapping --------------------------------------------
// -> to PU
pAdsParent^.register(ADR(fbAdsPm));  // PM -->PU
// -> to PM
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  pAdsParent^.iAdsParent := fbAdsPm;
  pAdsParent^.register(ADR(fbAdsPg[nCtr]));    // PG --> PM
  (*groups -> header tank group*)
  pAdsParent^.iAdsParent := _pModuleSetup^.pSetupInk^.pInkHeaderTankGroup^;
  pAdsParent^.register(ADR(fbAdsPg[nCtr]));    // PG --> HT Group
END_FOR

// -> to PG
FOR nCtr := 1 TO _nPc DO
  pAdsParent^.iAdsParent := fbAdsPg[_nPcToWorker_Mapping[nCtr]];
  pAdsParent^.register(_pPc[nCtr]^.pAdsBlock);     // PC --> PG
END_FOR;

// -> to PC
(*printhead*)
FOR nCtr := 1 TO _nPh DO
  pAdsParent^.iAdsParent := _pPc[_nPhToPc_Mapping[nCtr]]^.pAdsBlock^;
  pAdsParent^.register(_pPh[nCtr]^.pAdsBlock);    // PH --> PC
END_FOR;


// ADS Config ---------------------------------------------
(* -- PM PrintModuile*)
fbAdsPm.aName := _pModuleSetup^.aName;
fbAdsPm.config(
    bGeneralShiftX_Exist := TRUE
  , aGeneralShiftX_Unit  :=  'um'
  , nGeneralShiftX_Min   := -380_000
  , nGeneralShiftX_Max   := 1_000_000
  
  , bGeneralShiftY_Exist := TRUE
  , aGeneralShiftY_Unit  := 'um'
  , nGeneralShiftY_Min   := -8_001
  , nGeneralShiftY_Max   := 8_001
);

(* -- PG PrintGroup*)
FOR nCtr := 1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  fbAdsPg[nCtr].aName := F_Concat4(fbAdsPm.aName, ' - ', 'Printline ', TO_STRING(nCtr));
  fbAdsPg[nCtr].config(
       bShiftPositionX_Exist     := TRUE
     , aShiftPositionX_Unit      := 'um'
     , lShiftPositionX_Min       := 0
     , lShiftPositionX_Max       := 2_000_000
     
     , bShiftPositionY_Exist     := FALSE
     , aShiftPositionY_Unit      := 'pixel'
     , lShiftPositionY_Min       := 0
     , lShiftPositionY_Max       := 2147483647
     
     , bInkQuantity_Exist        := FALSE
     , aInkQuantity_Unit         := 'g/m^2'
     , lInkQuantity_Min          := 0
     , lInkQuantity_Max          := 100
     
     , bMaxPrintSpeed_Exist      := FALSE
     , aMaxPrintSpeed_Unit       := 'm/min'
     , lMaxPrintSpeed_Min        := 0
     , lMaxPrintSpeed_Max        := 100
  );
END_FOR;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="iPrintPosition" Id="{f2336ccb-c224-47c2-b3f9-51e309dacc92}">
      <Declaration><![CDATA[PROPERTY iPrintPosition : I_PrintPosition]]></Declaration>
      <Get Name="Get" Id="{d3ab9b51-282b-4f81-879b-e9cd3909a5a1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[iPrintPosition := _iPrintPosition;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="iStartPos" Id="{05ba1eff-b512-4303-8975-2d95448949d0}">
      <Declaration><![CDATA[PROPERTY iStartPos : I_StartPosDetect]]></Declaration>
      <Get Name="Get" Id="{00233417-0797-4bb8-b53b-df10725be94d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[iStartPos := _iStartPos;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Messaging" Id="{fc637a3e-5822-4fe0-a27c-11afd97711f1}">
      <Declaration><![CDATA[METHOD PRIVATE Messaging
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Messaging*)
fb_MsgHandler();
fb_MsgQueue();

// messages print module
//fbMsg[ 1](bI_Status := bTestMsg OR );

// message ack
IF fb_MsgQueue.bO_ReceiptMessage THEN
  IF bTestMsg THEN LogInfo('Ack messages'); END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="nTrackOffset" Id="{54b79013-69f8-4f06-8a74-7fa174bc28e4}" FolderPath="I_PositionEvent\">
      <Declaration><![CDATA[PROPERTY nTrackOffset : DINT
]]></Declaration>
      <Get Name="Get" Id="{42640a48-5d5c-4655-b83f-bcc9c38205ec}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nTrackOffset := nTrackPosMain;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="RegisterHw" Id="{a64271e1-4a66-4961-9be9-a58669016a07}">
      <Declaration><![CDATA[(*
  NOTE: Only needed because the Hw instances are outside of the Module.
        Please call the register HW prior initializing the Module itself!
*)
METHOD RegisterHw : BOOL
VAR_INPUT
  pPh : POINTER TO FB_PH;
  pPc : POINTER TO FB_PC;
  pMapDef : POINTER TO ST_MappingDefinition;
END_VAR
VAR
  i : UDINT;
  bFound : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pPh = 0 OR pPc = 0 OR pMapDef = 0 THEN LogError('registerHw invalid parameter'); RETURN; END_IF
IF _nPc >= GVL_Maxliner.nC_MaxPcPerPm THEN LogError('register hw: too many PCs registered'); RETURN; END_IF
IF _nPh >= GVL_Maxliner.nC_MaxPhPerPm THEN LogError('register hw: too many PHs registered'); RETURN; END_IF

// PC 
bFound := FALSE;
FOR i:=1 TO _nPc DO   // search for existing pc
  IF _pPc[i] = pPc THEN bFound := TRUE; EXIT; END_IF
END_FOR
IF NOT bFound THEN    // add if unknown
  _nPc := _nPc + 1;
  _pPc                [_nPc] := pPc;
  _nPcToWorker_Mapping[_nPc] := pMapDef^.nPg;  // save mapping
  _nPcToPgAbsoluteIdx [_nPc] := pMapDef^.nPgAbs;  // save PCs mapping to PG absolute
ELSE
  ; // ignore new pc
END_IF

// PH
bFound := FALSE;
FOR i:=1 TO _nPh DO   // search for existing ph
  IF _pPh[i] = pPh THEN bFound := TRUE; EXIT; END_IF
END_FOR
IF NOT bFound THEN    // add if unknown
  _nPh := _nPh + 1;
  _pPh                [_nPh] := pPh;
  _nPhToPc_Mapping    [_nPh] := pMapDef^.nPc;
  _nPhToPcCh_Mapping  [_nPh] := pMapDef^.nPcCh;
  _nPhToWorker_Mapping[_nPh] := pMapDef^.nPg;
  _nPhToPgAbsoluteIdx [_nPh] := pMapDef^.nPgAbs;
ELSE
  LogWarning(F_Concat3('FB_PH=', pPh^.sName, ', already registered, ignore'));
END_IF

RegisterHw := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="remove" Id="{98ee8da0-e987-490e-aba9-ec9483e43dea}" FolderPath="I_PositionEvent\">
      <Declaration><![CDATA[(*
  Container will be released (maybe destroyed) from this tracker and not available anymore after this call.
*)
METHOD remove
VAR_INPUT
	(*container at triggered event position*)
	iCT	: I_CT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInit THEN RETURN; END_IF

// not implemented yet]]></ST>
      </Implementation>
    </Method>
    <Method Name="setLogLevels" Id="{8c3912fb-002d-4d6a-b410-9b7f8323f1f4}">
      <Declaration><![CDATA[METHOD PROTECTED setLogLevels
VAR_INPUT
  lvl : E_LogSeverity;
END_VAR
VAR
  i : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set logging levels
fbPrintPosition.LogLevel     := lvl;
fbWorkerCamera.LogLevel      := lvl;
fbWorkerDeformation.LogLevel := lvl;
FOR i:=1 TO GVL_Maxliner.nC_MaxWorkerPrintPerPm DO
  fbWorkerPrint[i].LogLevel := lvl;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetupHw" Id="{6f36d6da-85e5-4311-8147-c2acc9b0c3da}">
      <Declaration><![CDATA[(*
  Init/Setup print hw & link to mapped handlers.
  NOTE: override this method if it does not match the default mapping.
*)
METHOD PRIVATE SetupHw
VAR
  i : UDINT;
  sPhFdlCfg_ImgMap : ST_PH_FileDownloadCfg;
  aName : T_MaxString;
  nOldPg : UDINT;
  nPg, nPc : UDINT;
  nRelativeCtr : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// check parameters
IF _iPrintGlobal.iHardwarePool = 0 THEN LogError('SetupHw: invalid hw pool reference, do not setup'); RETURN; END_IF

IF _pModuleSetup = 0 THEN LogError('Module setup not given, ignore SetupHw'); END_IF

// PC -------------------------------------------
FOR i := 1 TO _nPc DO
  // check settings
  IF _pPc[i] = 0 THEN LogError(F_Concat4('SetupHw: invalid pc mapping','_pPc[',TO_STRING(i),']=0'));
    CONTINUE;
	END_IF
  
  // build ads name
  IF nOldPg <> _nPcToPgAbsoluteIdx[i] THEN nRelativeCtr := 1; nOldPg := _nPcToPgAbsoluteIdx[i]; END_IF  // create cb counter relative to pg
  aName := F_Concat4('Controller Board', TO_STRING(_nPcToPgAbsoluteIdx[i]), '.', TO_STRING(nRelativeCtr));
  nRelativeCtr := nRelativeCtr + 1;

  // init
  _pPc[i]^.Init(    aName                 := aName
                  , sAmsNetIdLocalHost    := _pModuleSetup^.pSetupPrint^.aAmsNetId_Localhost
                  , sAmsNetIdIo           := _pModuleSetup^.pSetupPrint^.aAmsNetId_Io
                  , nEcatSlaveAddr        := TO_UINT(_pModuleSetup^.pSetupPrint^.nEcatAddr_Pc_Base + (i-1))
                  , nBlockId              := TO_INT(ePr_BLK_PC)
                  , pOd                   := _pModuleSetup^.pSetupPrint^.pOd
                  , tWaveDownload         := T#10S
                  , bHeaterEnableExist    := TRUE
                  , bPrintEnableExist     := TRUE
                  , sFilePath             := _pModuleSetup^.pSetupPrint^.aCfgPath
                  , ePcType               := E_PcTypes.Pc_RicohGen
                  );
  // register to worker
  fbWorkerPrint[_nPcToWorker_Mapping[i]].registerPc(iNewPC:=_pPc[i]^);
  
  // register to hw pool
  _iPrintGlobal.iHardwarePool.registerPc(pNewPc:=_pPc[i]);
   
END_FOR

// PH -------------------------------------------
nOldPg := 1; nRelativeCtr := 1;
FOR i := 1 TO _nPh DO
  nPc := _nPhToPc_Mapping[i];
  nPg := _nPcToPgAbsoluteIdx[nPc];
  // check config
  IF _pPh[i] = 0 OR _pPc[nPc] = 0 THEN LogError(F_Concat4('SetupHw: invalid ph mapping','_pPh[',TO_STRING(i),']=0'));
    CONTINUE;
	END_IF
  
  // build ads name
  IF nOldPg <> nPg THEN nRelativeCtr := 1; nOldPg := nPg; END_IF  // create cb counter relative to pg
  aName := F_Concat4('Printhead', TO_STRING(nPg), '.', TO_STRING(nRelativeCtr));
  nRelativeCtr := nRelativeCtr + 1;
  
  _pPh[i]^.init(    aName                 := aName
                  , sPhDef                := _pModuleSetup^.pSetupPrint^.sPHType
                  , tTempMonitor          := T#45S
                  , iChannel              := _nPhToPcCh_Mapping[i]
                  , bPositionX_Exist      := TRUE
                  , aPositionX_Unit       := 'um'
                  , lPositionX_Min        := 0
                  , lPositionX_Max        := 1_000_000
                  , bPositionY_Exist      := FALSE
                  , aPositionY_Unit       := 'pixel'
                  , lPositionY_Min        := 0
                  , lPositionY_Max        := 100_000 
                  , bShiftPositionX_Exist := FALSE      
                  , aShiftPositionX_Unit  := 'um'
                  , lShiftPositionX_Min   := 0      
                  , lShiftPositionX_Max   := 1000      
                  , bShiftPositionY_Exist := FALSE
                  , aShiftPositionY_Unit  := 'pixel'
                  , lShiftPositionY_Min   := 0
                  , lShiftPositionY_Max   := 100_000       
                  , bVoltageScale_Exist   := TRUE  
                  , aVoltageScale_Unit    := '%'
                  , fVoltageScale_Min     := 90.0  
                  , fVoltageScale_Max     := 110.0 
                  );

  _pPh[i]^.initTempMonitor(fPhTempDeviation := _pModuleSetup^.pSetupPrint^.fPhTempDeviation, tTempMonitor:=T#45S);   // overwrite default temperatur deviation
  
  // edit default file download config for ImageMap file --> disable file downloader
  _pPh[i]^.getFileDownloadConfig(E_PhFileSelection.eImageMap, stConfig=>sPhFdlCfg_ImgMap);
  sPhFdlCfg_ImgMap.bEnable := FALSE;
  _pPh[i]^.setFileDownloadConfig(eDownloader:=E_PhFileSelection.eImageMap, stConfig:=sPhFdlCfg_ImgMap);

  _pPh[i]^.LogLevel := E_LogSeverity.Info;
  
  // link ph <-> pc if not done externally
  _pPc[_nPhToPc_Mapping[i]]^.registerPH(iPH :=_pPh[i]^, nCh := TO_UINT(_nPhToPcCh_Mapping[i]));
  
  // register to worker
  fbWorkerPrint[_nPhToWorker_Mapping[i]].registerPh(iPH:=_pPh[i]^);
  
  // register to hw pool
  _iPrintGlobal.iHardwarePool.registerPh(pNewPh:=_pPh[i]);

END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimUpdate" Id="{9df29875-70e5-4828-893d-4cc0b114f6d0}" FolderPath="Simulation\">
      <Declaration><![CDATA[METHOD PRIVATE SimUpdate
VAR_INPUT
END_VAR

VAR_INST
  rfTrig_SimEnable : RF_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rfTrig_SimEnable(CLK := fbSim.bSimEnable);
IF    rfTrig_SimEnable.RT THEN
  fbPrintPosition.bSimEnable := TRUE;

ELSIF rfTrig_SimEnable.FT THEN
  // ev. disable
  fbPrintPosition.bSimEnable := FALSE;
  
ELSIF fbSim.bSimEnable THEN
  // enabled
  ;
ELSE
  ; // disabled
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="trigger" Id="{3e79aca3-6f74-40d0-a259-c4f820684325}" FolderPath="I_PositionEvent\">
      <Declaration><![CDATA[(*
  Container triggered at position - callback.
*)
METHOD trigger : BOOL
VAR_INPUT
	sEvPos	: ST_PositionEventData;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInit THEN RETURN; END_IF
IF sEvPos.iCT = 0 THEN RETURN; END_IF


// buffer new ct
_bNewCT := TRUE;
_iNewCT := sEvPos.iCT;

LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat3(
  F_Concat2(_pModuleSetup^.aName, ' NewCT PosEv:'),
  F_Concat2(' at (Main)TrackPos:', TO_STRING(sEvPos.nTrigPos)),
  F_Concat2(' with CT:', sEvPos.iCT.print(0))
));
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_PrintModule_Maxliner">
      <LineId Id="7930" Count="0" />
      <LineId Id="8149" Count="0" />
      <LineId Id="8776" Count="3" />
      <LineId Id="8786" Count="37" />
      <LineId Id="8152" Count="0" />
      <LineId Id="8155" Count="1" />
      <LineId Id="8158" Count="0" />
      <LineId Id="8163" Count="0" />
      <LineId Id="8162" Count="0" />
      <LineId Id="8584" Count="0" />
      <LineId Id="8175" Count="0" />
      <LineId Id="8174" Count="0" />
      <LineId Id="8164" Count="0" />
      <LineId Id="8160" Count="0" />
      <LineId Id="8168" Count="2" />
      <LineId Id="8172" Count="0" />
      <LineId Id="8268" Count="0" />
      <LineId Id="8360" Count="0" />
      <LineId Id="7932" Count="2" />
      <LineId Id="8361" Count="0" />
      <LineId Id="7935" Count="3" />
      <LineId Id="8146" Count="2" />
      <LineId Id="8143" Count="0" />
      <LineId Id="8165" Count="1" />
      <LineId Id="7962" Count="0" />
      <LineId Id="7964" Count="0" />
      <LineId Id="8176" Count="0" />
      <LineId Id="7965" Count="0" />
      <LineId Id="7973" Count="37" />
      <LineId Id="8678" Count="0" />
      <LineId Id="8011" Count="14" />
      <LineId Id="8027" Count="4" />
      <LineId Id="8491" Count="0" />
      <LineId Id="8457" Count="0" />
      <LineId Id="8459" Count="0" />
      <LineId Id="8486" Count="0" />
      <LineId Id="8488" Count="1" />
      <LineId Id="8458" Count="0" />
      <LineId Id="8487" Count="0" />
      <LineId Id="8032" Count="16" />
      <LineId Id="9054" Count="5" />
      <LineId Id="8824" Count="0" />
      <LineId Id="8826" Count="1" />
      <LineId Id="8935" Count="0" />
      <LineId Id="8937" Count="0" />
      <LineId Id="8936" Count="0" />
      <LineId Id="9061" Count="2" />
      <LineId Id="770" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.bMoving.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.bSelectedForProduction.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.bSimEnable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.bSimEnable.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.bSyncCmd.Get">
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.checkFormatLength">
      <LineId Id="13" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="49" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="25" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.checkHwSyncRequest">
      <LineId Id="8" Count="7" />
      <LineId Id="18" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.checkReadyForStop">
      <LineId Id="22" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="34" Count="2" />
      <LineId Id="30" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.checkSpeed">
      <LineId Id="30" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.fDetectToPm.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.fPmDistToPrev.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.fPmDistToPrev.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.fPmMainTrackPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.fPmMainTrackPos.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.getInkQuantity">
      <LineId Id="6" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.Init">
      <LineId Id="1805" Count="0" />
      <LineId Id="2092" Count="0" />
      <LineId Id="2087" Count="4" />
      <LineId Id="2085" Count="0" />
      <LineId Id="1808" Count="5" />
      <LineId Id="1815" Count="5" />
      <LineId Id="1982" Count="0" />
      <LineId Id="1979" Count="2" />
      <LineId Id="1906" Count="0" />
      <LineId Id="1826" Count="1" />
      <LineId Id="1908" Count="2" />
      <LineId Id="1828" Count="0" />
      <LineId Id="2005" Count="3" />
      <LineId Id="1829" Count="13" />
      <LineId Id="1951" Count="6" />
      <LineId Id="1843" Count="15" />
      <LineId Id="1959" Count="0" />
      <LineId Id="1860" Count="0" />
      <LineId Id="1958" Count="0" />
      <LineId Id="1861" Count="6" />
      <LineId Id="2032" Count="0" />
      <LineId Id="2055" Count="2" />
      <LineId Id="2062" Count="0" />
      <LineId Id="2058" Count="3" />
      <LineId Id="2031" Count="0" />
      <LineId Id="1868" Count="8" />
      <LineId Id="1931" Count="0" />
      <LineId Id="1877" Count="4" />
      <LineId Id="1930" Count="0" />
      <LineId Id="1883" Count="1" />
      <LineId Id="1783" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.InitAds">
      <LineId Id="6" Count="23" />
      <LineId Id="61" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="104" Count="5" />
      <LineId Id="125" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="112" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="32" Count="7" />
      <LineId Id="124" Count="0" />
      <LineId Id="41" Count="3" />
      <LineId Id="46" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="47" Count="2" />
      <LineId Id="122" Count="0" />
      <LineId Id="51" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.iPrintPosition.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.iStartPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.Messaging">
      <LineId Id="48" Count="2" />
      <LineId Id="80" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.nTrackOffset.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.RegisterHw">
      <LineId Id="184" Count="10" />
      <LineId Id="215" Count="0" />
      <LineId Id="214" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="195" Count="10" />
      <LineId Id="216" Count="2" />
      <LineId Id="232" Count="0" />
      <LineId Id="247" Count="0" />
      <LineId Id="206" Count="2" />
      <LineId Id="212" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.remove">
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.setLogLevels">
      <LineId Id="5" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.SetupHw">
      <LineId Id="143" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="153" Count="35" />
      <LineId Id="257" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="260" Count="1" />
      <LineId Id="259" Count="0" />
      <LineId Id="191" Count="53" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.SimUpdate">
      <LineId Id="53" Count="1" />
      <LineId Id="61" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="79" Count="2" />
      <LineId Id="90" Count="6" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_PrintModule_Maxliner.trigger">
      <LineId Id="65" Count="12" />
      <LineId Id="18" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
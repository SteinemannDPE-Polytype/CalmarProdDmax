<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.3">
  <POU Name="FB_MarkCamera" Id="{62cb877c-e9b0-4721-9386-d3b41a5bdde5}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Mark camera system
  2 mark sensors detect sheet marks.   
*)
FUNCTION_BLOCK FB_MarkCamera EXTENDS FB_CameraBase 

VAR_INPUT
  IbSensorState       AT%I* : ARRAY [1..cNbSensors] OF BOOL;        (*Mark sensor state*)
  ItTimeStampPos      AT%I* : ARRAY [1..cNbSensors] OF T_DCTIME64;  (*TimeStamp Pos_Edge @EL1252*)
  ItTimeStampNeg      AT%I* : ARRAY [1..cNbSensors] OF T_DCTIME64;  (*TimeStamp Neg_Edge @EL1252*)

  IfConveyorSpeed           : LREAL;      (*Actual speed of conveyor [m/s]*)
  IfMasterPosition          : LREAL;      (*Master position [µm]*)
END_VAR

VAR
  nCounter                  : UDINT;

  _fSensorDistance          : REAL := 1.0;    (*Distance between the two sensors [m]*)
  _fMarkPositionX           : REAL := 0.010;  (*Distance sheet edge to mark position [m]*)
  _fMarkSizeX               : REAL;           (*Mark size X [mm]*)
  _fMarkSizeY               : REAL;           (*Mark size Y [mm]*)

  tSensorRisingEdge         : ARRAY [1..cNbSensors] OF T_DCTIME64;
  tSensorFallingEdge        : ARRAY [1..cNbSensors] OF T_DCTIME64;
  bMemSensorState           : ARRAY [1..cNbSensors] OF BOOL;       (*Mem mark sensor state*)
  bInhibSensor              : ARRAY [1..cNbSensors] OF BOOL;       (*Inhibit sensor signals, TRUE=inhibit*)
  bSensorStateOK            : ARRAY [1..cNbSensors] OF BOOL;       (*Mark sensor state ok*)
  fSensorDuration           : ARRAY [1..cNbSensors] OF REAL;       (*Sensor signal duration [ns]*)
  fSensorLength             : ARRAY [1..cNbSensors] OF REAL;       (*Sensor signal length [mm]*)
  fS1S2EdgeDistance         : REAL;       (*Edge distance between sensors [mm]*)
  fLateralOffset            : REAL;       (*Lateral offset [mm]*)
  fMemMasterPosition        : LREAL;      (*Mem master position [µm]*)
  bStopCondition            : BOOL;       (*Condition for stop trigger*)
END_VAR

VAR CONSTANT                
  cNbSensors                : UDINT := 2; (*Number of mark sensors*)
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT _bInitialized THEN RETURN; END_IF

(*check parameter*)
IF _fSensorDistance = 0 THEN
	_fSensorDistance := 1.0;
END_IF;

FOR nCounter := 1 TO cNbSensors DO
  (* -------- Detection of rising edge on sensor --------*)
  IF IbSensorState[nCounter] AND NOT bMemSensorState[nCounter] AND NOT bInhibSensor[nCounter] THEN
    tSensorRisingEdge[nCounter] := ItTimeStampPos[nCounter];
    fMemMasterPosition          := IfMasterPosition;
  END_IF;
  
  (* -------- Detection of falling edge --------*)
  IF NOT IbSensorState[nCounter] AND bMemSensorState[nCounter] AND NOT bInhibSensor[nCounter] THEN
    tSensorFallingEdge[nCounter] := ItTimeStampNeg[nCounter];
    fSensorDuration   [nCounter] := LREAL_TO_REAL(ULINT_TO_LREAL(tSensorFallingEdge[nCounter]) - ULINT_TO_LREAL(tSensorRisingEdge[nCounter]));		(* Calculate how long the signal was ON *)
    fSensorLength     [nCounter] := LREAL_TO_REAL(fSensorDuration[nCounter] * IfConveyorSpeed / 1_000_000_000);			(* Calculate the equivalence in mm *)
    bSensorStateOK    [nCounter] := TRUE;   (* now the function can continue to Angle & Offset calculation *)
    bInhibSensor      [nCounter] := TRUE;
  END_IF;
  
  bMemSensorState[nCounter] := IbSensorState[nCounter];			(* Memorization of the sensor1 state for next cycle *)
END_FOR

(* ------------ ANGLE & OFFSET CALCULATION ----------------- *)
IF bSensorStateOK[1] AND bSensorStateOK[2] THEN
  fS1S2EdgeDistance := LREAL_TO_REAL(ULINT_TO_LREAL(tSensorRisingEdge[1] - tSensorRisingEdge[2]) / 1_000_000 * IfConveyorSpeed);	(* Calculate the difference in mm between S1 and S2 trigger *)

  fLateralOffset := (_fMarkSizeY / _fMarkSizeX) * (fSensorLength[1] - fSensorLength[2]) / 2;  (* Evaluation of the offset for each mark *)

  IF _iCameraSink <> 0 THEN
    (*Mark1*)
    stCamPoint.x_ref := F_MeterToSubPixelReal( _fMarkPositionX                                      (*[m]*)
                                              , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
    stCamPoint.y_ref := F_MeterToSubPixelReal( (_fSubstrateWidth / 2) - (_fSensorDistance / 2)       (*[m]*)
                                              , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
    stCamPoint.dx    := 0;
    stCamPoint.dy    := F_MeterToSubPixelReal( fLateralOffset * 0.001                              (*[mm] => [m]*)
                                              , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
  
    _iCameraSink.AddCamPoint(stCamPoint);
    _nRxCamPoints := _nRxCamPoints + 1 ;
  
    (*Mark2*)
    stCamPoint.x_ref := F_MeterToSubPixelReal( _fMarkPositionX                                      (*[m]*)
                                             , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
    stCamPoint.y_ref := F_MeterToSubPixelReal( (_fSubstrateWidth / 2) - (_fSensorDistance / 2) + _fSensorDistance  (*[m]*)
                                             , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
    stCamPoint.dx    := F_MeterToSubPixelReal( fS1S2EdgeDistance * 0.001                           (*[mm] => [m]*)
                                             , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
    stCamPoint.dy    := F_MeterToSubPixelReal( fLateralOffset * 0.001                              (*[mm] => [m]*)
                                             , UDINT_TO_LREAL(_nPrintUnitResolution));             (*Result should be in pixels*)
  
    _iCameraSink.AddCamPoint(stCamPoint);
    _nRxCamPoints := _nRxCamPoints + 1;
  END_IF;

	bSensorStateOK[1]  := FALSE;
	bSensorStateOK[2]  := FALSE;
END_IF;


(*------------ start and stop signal treatment ------------*)
(*generate stop trigger*)
bStopCondition := (IfMasterPosition >= (fMemMasterPosition + (_fSubstrateLength * 1_000_000)));

IF bStopCondition AND (bInhibSensor[1] OR bInhibSensor[2]) THEN
  bInhibSensor[1] := FALSE;
  bInhibSensor[2] := FALSE;
END_IF;

{warning 'TODO: implement PUC messages eCPr_PrintMarkError1&2'}

]]></ST>
    </Implementation>
    <Property Name="eCameraMode" Id="{845cfc93-98bd-4f36-a45c-de0019dfb56c}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY eCameraMode : E_CameraMode
]]></Declaration>
      <Get Name="Get" Id="{582a52aa-30fa-4f2c-af0f-370536c1383f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eCameraMode := _eCameraMode;
IF _eCameraMode = E_CameraMode.Auto THEN
  eCameraMode := E_CameraMode.XYR;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="eDeviceType" Id="{d3f12ef1-6e01-4f71-9b2b-191574581a71}">
      <Declaration><![CDATA[PROPERTY eDeviceType : E_CameraDevice]]></Declaration>
      <Get Name="Get" Id="{7c75b9a8-752b-45cd-a08e-f2646fbdf889}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eDeviceType := E_CameraDevice.PrintMark;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="fMarkPositionX" Id="{dfa27d9d-b747-4972-8b98-2d1e739f2fb6}">
      <Declaration><![CDATA[PROPERTY fMarkPositionX : REAL]]></Declaration>
      <Set Name="Set" Id="{d06af790-a95c-41fb-82a6-5f62a1f0dd05}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fMarkPositionX := fMarkPositionX;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="fMarkSizeX" Id="{e4c36257-d567-4a52-8203-d82247a7892c}">
      <Declaration><![CDATA[PROPERTY fMarkSizeX : REAL]]></Declaration>
      <Set Name="Set" Id="{fefaa85d-d74a-4801-88ac-96304108e42b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fMarkSizeX := fMarkSizeX;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="fMarkSizeY" Id="{733a283a-7379-4d44-8afb-d1a4ea1efba7}">
      <Declaration><![CDATA[PROPERTY fMarkSizeY : REAL]]></Declaration>
      <Set Name="Set" Id="{d10e22f6-3db8-4fd7-8990-0d0b7188d76c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fMarkSizeY := fMarkSizeY;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="fSensorDistance" Id="{37b2376d-1ece-454e-95b7-1fe6f79e0791}">
      <Declaration><![CDATA[PROPERTY fSensorDistance : REAL]]></Declaration>
      <Set Name="Set" Id="{5257d07b-85a5-4752-ae64-3b6beed8459c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fSensorDistance := fSensorDistance;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="GetCamStatus" Id="{d2ba91bf-3458-4e6f-bb4d-7d46512f3f33}">
      <Declaration><![CDATA[METHOD GetCamStatus : BOOL
VAR_OUTPUT
  bConnectionOK  : BOOL;    // Camera connected
  bTeachOk       : BOOL;    // Teach successful
  nTeachedPoints : UDINT;   // Teached points for this job
  nScannedPoints : UDINT;   // Scanned points on current sheet
  bCamStarted    : BOOL;    // Camera trigger is active, cam started
  bCamDone       : BOOL;    // Camera finished on last CT
  bErrors        : ARRAY[1..GVL_Camera.nC_NbCamErrors] OF BOOL;  // generic error flag list
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bConnectionOK  := TRUE;
bTeachOk       := TRUE; // NO teach availabe
nTeachedPoints := 2;    // 2 marks only
nScannedPoints := _nRxCamPoints;
bCamStarted    := _bCamStarted;
bCamDone       := _bCamDone;

GetCamStatus := bConnectionOK AND bTeachOk;   // camera ready]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitMarkCamera" Id="{8ba11a53-c89e-4a7c-b318-018af5a1d6a7}">
      <Declaration><![CDATA[METHOD InitMarkCamera
VAR_INPUT
  nPrintUnitResolution         : UDINT;    (*printhead pixel resolution [dpi]*)
  nPrintUnitSubPx              : UDINT;    (*print unit subPixel resolution [SubPx]*)
  iCameraTrigger               : I_CameraTrigger;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init( nPrintUnitResolution      := nPrintUnitResolution
           , nPrintUnitSubPx           := nPrintUnitSubPx
           , iCameraTrigger            := iCameraTrigger
           , bUseCameraTrigger         := FALSE
           , bUseCameraTriggerFeedback := FALSE);

_bInitialized := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="setCameraMode" Id="{c13a6c4e-e085-464b-875f-b2fc65e85833}">
      <Declaration><![CDATA[(*
  Set mode to camera.
  :return: TRUE if success
*)
METHOD setCameraMode : BOOL
VAR_INPUT
  eCameraMode : E_CameraMode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eCameraMode = E_CameraMode.NoCorrection OR  // supported modi
   eCameraMode = E_CameraMode.XYR THEN
   
  _eCameraMode := eCameraMode;  // set desired mode
  setCameraMode := TRUE;
ELSE
  LogError(F_Concat3('Camera mode=', TO_STRING(eCameraMode), ' not supported by camera'));
  _eCameraMode := E_CameraMode.NoCorrection;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="sName" Id="{23af5994-197e-4d4a-8550-73c2a3b76199}">
      <Declaration><![CDATA[{attribute 'monitoring':='variable'}
PROPERTY sName : STRING
]]></Declaration>
      <Get Name="Get" Id="{60876c21-e885-417e-997f-d5aa7fd83bc2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sName := 'Printmarks';]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="FB_MarkCamera">
      <LineId Id="617" Count="74" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.eCameraMode.Get">
      <LineId Id="13" Count="2" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.eDeviceType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.fMarkPositionX.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.fMarkSizeX.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.fMarkSizeY.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.fSensorDistance.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.GetCamStatus">
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="4" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.InitMarkCamera">
      <LineId Id="5" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="53" Count="2" />
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.setCameraMode">
      <LineId Id="24" Count="1" />
      <LineId Id="44" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkCamera.sName.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkDetection_v2" Id="{464ac74c-68f1-45cc-a863-0d379752dfed}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Detects Marks and generates StartTrigger based on one EL1252 timestamp input I/O.
  Implements a CameraTrigger instance as well.
  
  Additionally:
    - returns lateral offset (+/- in [m]) to center of detected marks.
    - manages & supervises mark sequence
    - is a CameraTrigger as well
    - supports simulation mode
  
  NOTE: 
    - a mark has always a rising and falling edge of the sensor (triangle)
    - center position is the middle of the triangular mark

*)
FUNCTION_BLOCK FB_MarkDetection_v2 EXTENDS T_NamedBase IMPLEMENTS I_StartPosDetect, I_CameraTrigger, I_Sim
VAR_INPUT
  (*EL1252*)
  bIKp_StartSensor          AT%I* : BOOL;             (*Sensor start trigger*)
  tIKp_TimeStampPos         AT%I* : T_DCTIME64;       (*TimeStamp Pos_Edge @EL1252*)
  tIKn_TimeStampNeg         AT%I* : T_DCTIME64;       (*TimeStamp Neg_Edge @EL1252*)

  // configuration
  bEnable                         : BOOL;             (*Enable start pos detection sensor (from extern)*)
  bAutomaticMode                  : BOOL;             (*machine is in automatic mode *)
  nCurrentPos                     : DINT;             (*current position in Pulses/Subpixels*)
  fCurrentSpeed                   : LREAL;            (*actual speed of conveyor in [m/s]*)
  bReverse                        : BOOL;             (*reverse printing same roll feeded in opposite direction, check falling edge in this case*)
  
  // Debug & Test
  bManualTrigger                  : BOOL;             // Manual start trigger
  bManualReset                    : BOOL;             // Manaul reset detection
END_VAR
VAR
  bInitOk                         : BOOL;             // fb initialized

  // config
  _fResolution                    : LREAL := 1;       // current used print resolution (dpi*SubPx)
  _pFbMarkDefinition              : POINTER TO FB_MarkDefinition;      // mark definition
  _iCamera                        : I_Camera;         // camera interface
  // settings                                    
  _bUseCameraTrigger              : BOOL;             // (cam specific setting) Generate camera trigger output
  _bUseCameraTriggerFeedback      : BOOL;             // (cam specific setting) Evaluate camera triggered feedback
  _bCamManualTeachMode            : BOOL;             // cam in manual teach mode
  _fSubstrateLength               : LREAL;            // Substrate length in [m] (should be repeat length)
  _fTriggerDistance               : LREAL;            // Distance between Sensor and Trigger [m]
  _fTriggerLength                 : LREAL := 10;      // Length of trigger signal in ms, min. 3 bus cycles
  _iActiveCam                     : I_CameraTriggerDevice;  // active camera interface (set by Enable() on I_CameraTrigger)

  // sensor
  bSensorSignal                   : BOOL;             (*internal sensor signal*)
  tSensorRisingTimeStamp          : T_DCTIME64;
  tSensorFallingTimeStamp         : T_DCTIME64;
  bCamValid                       : BOOL;             (*camera is valid*)
  bMarksTeached                   : BOOL;             (*definition is valid marks&substrate*)
  bSpeedValid                     : BOOL;             (*speed is valid*)
  bTriggerArmed                   : BOOL;             (*trigger is armed*)
  bDetectionRunning               : BOOL;             (*detection running an initial start mark was found*)
  bSheetActive                    : BOOL;             (*sheet is scanning*)
    
  // helper
  rfT_Enable                      : RF_TRIG;          // edge detection
  isStartMark                     : BOOL;
  isMarkMissing                   : BOOL;
  nMarkSelection                  : UDINT := 1;       // Current selected mask to search
  pMarkSearch                     : POINTER TO ST_MarkDefinition;
  _fSubstrateLengthEffective      : LREAL;            // Substrate length in [m]

  
  // time calculations
  tNowDc                          : T_DCTIME64;       // Get Current Timestamp (now)
  fCycleTime                      : LREAL;            // Current calculated cycle time [s]
  
  // I_StartPosDetect
  _bStartTrig                     : BOOL;             // Start Trigger Edge
  _nX0                            : DINT;             // X0 Position [SubPx]
  _bValid                         : BOOL;             // valid start trigger
  
  // errors
  nCtrSensorDetectError           : UDINT;            // senor detect errors counter invalid signals
  nCtrIgnoredMarks                : UDINT;
  bNoStartMarkDetected            : BOOL;             // no start mark detected after x repeats
  bInvalidRepeatLength            : BOOL;             // invalid repeat length (StartMarks too close or too far away from each other)
  bInvalidMarkDetected            : BOOL;
  bMissingMarks                   : BOOL;
  
  //bInvalidMarks_TooLong           : BOOL;             // marks too long
  //bInvalidMarks_TooShort          : BOOL;             // marks too short
  //bLenNotInRange_Repeat           : BOOL;             // Effective length not in range
  //bStartOverrun_Repeat            : BOOL;             // too many starts
  //bMissingMarks_Repeat            : BOOL;             // ...
  //bMarksTooShort_Repeat           : BOOL;             // ...
  
  
  // simulation & debug
  _bSimEnable                     : BOOL;             // simulation mode enabled
  _nSimMode                       : UDINT;            // simulation mode 0=Simulate Marks, 1=Simulate Sensor 
  _bVerbose                       : BOOL;             // verbose mode
  _fSubstrateGap                  : LREAL;            // Gap between two substrates (sheets/repeats) for simulation
  
  // local for checkForMark
  rfEdgeSensor                    : RF_TRIG;          // edge detection start trigger
  bResetDetection                 : BOOL;             // Reset request for checkForMark() internals
  tRisingEdge, tFallingEdge       : T_DCTIME64;       // detected edges
  nRisingPos, nFallingPos         : DINT;             // detected [SubPx] pos
  fMarkDuration                   : LREAL;            // duration in rising-falling time delta
  nPosRepeatSupervision           : DINT;             // position sample for supervision of missing StartMarks
  nLastGeneratedStartMarkPosition : DINT;             // last "generated" start mark
  bMarkStartDetected              : BOOL;             // mark started
  bMarkEndDetected                : BOOL;             // marks end reached
  bInhibitTrigger                 : BOOL;             // inhibit sensor signals, TRUE=inhibit
  
  // history 
  // - repeat
  sRepeatHistory : ARRAY[0..nC_HistorySize-1] OF ST_RepeatHistory;   // detection history
  nRepeatCt : UDINT;                 // history entry selector
  // - marks
  sMarkHistory : ARRAY[0..nC_HistorySize-1] OF ST_MarkDefinition;   // history of detected marks
  nMarkHistoryCt : UDINT;            // history entry selector
  // test
  bSim_Mark_Displacement : BOOL;
  fSim_Dx_Fix, fSim_Dy_Fix : LREAL;     // simulate some fix deviation of detected marks [m]
END_VAR
VAR PERSISTENT
  bR_TerminateLast                : BOOL;             // Terminate sheet with last defined & detected mark
  nR_SpeedMavFilterSamples        : UINT := 0;        // moving average filter samples = 0 deactivated
END_VAR
VAR CONSTANT
  fC_MinimalSpeed                 : LREAL := 0.010;   // [m/s] speed valid (used for trigger activation)
  fC_MarkLengthMargin             : LREAL := 0.015;   // [m] used for mark end position supervision (mark end missed)
  fC_MaxSubstrateFactor           : LREAL := 1.1;     // factor which the sheet length can be max. longer
  fC_MinSubstrateFactor           : LREAL := 0.9;     // factor which the sheet length can be smaller
  nC_MaxRepeatsWithoutStart       : LREAL := 3;       // max repeats (theoretical distance) without a detected start trigger before error
  nC_AreaMarkSensorOk             : INT := 10;        // [%] Area with the correct arrangement of the mark sensor
  nC_HistorySize                  : UDINT := 20;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// check parameter
IF NOT bInitOk THEN RETURN; END_IF

// General calculations
bSpeedValid   := fCurrentSpeed > fC_MinimalSpeed;                // speed valid (ignore trigger if not moving)
bCamValid     := SEL(_iActiveCam<>0, FALSE, TRUE);               // camera valid (ignore trigger otherwise)
bMarksTeached    := (_fSubstrateLength > 0 AND _pFbMarkDefinition^.nMarks > 0);
tNowDc        := F_GetCurDcTaskTime64();                         // current dc time (most accurate time stamp we have)
fCycleTime    := calcCycleTime(tCurrent:=tNowDc);                // calculate cycle time of this fb
bTriggerArmed :=  bCamValid AND bSpeedValid AND bEnable AND bMarksTeached AND (bAutomaticMode OR _bCamManualTeachMode OR _bSimEnable);   // trigger

IF bCamValid THEN    // (not yet used) save dynamic changable settings
  _fTriggerDistance := _iActiveCam.fTriggerDistance;
  _fTriggerLength   := _iActiveCam.fTriggerPulseLength;
END_IF

_bValid := _bStartTrig := FALSE;    // default values (outputs and properties)

manualTrigger();     // handle manual trigger


// enable & reset
rfT_Enable(CLK:=bTriggerArmed);             // edge detection for detection started
IF rfT_Enable.RT OR rfT_Enable.FT OR bManualReset THEN Reset(); bManualReset:=FALSE; END_IF;
IF NOT bEnable THEN RETURN; END_IF    // do nothing if not enabled
IF NOT bTriggerArmed THEN RETURN; END_IF

bSensorSignal := bIKp_StartSensor;
tSensorRisingTimeStamp := tIKp_TimeStampPos;
tSensorFallingTimeStamp := tIKn_TimeStampNeg;


// Work
// - detect marks
//   - detect missing marks (based on teach definition, type and a margin)
//   - maybe replace missing marks (trend or teach)
// - handle StartTrigger if StartMark rising edge
// - handle Mark detected position (y-correction)
// - save mark, keep tracking of detected marks, (error handling if some missed)
// - send mark to camera


(*State Machine ----------------------------------------------------------------*)
// select mark
IF nMarkSelection > _pFbMarkDefinition^.nMarks THEN nMarkSelection := 1; END_IF  // fix invalid selection
pMarkSearch :=  _pFbMarkDefinition^.getMark(nIdx:=TO_DINT(nMarkSelection));

// search for mark
IF searchForMark(pMark:=pMarkSearch, bStartMark=>isStartMark, bMissing=>isMarkMissing) THEN 

  IF _bVerbose THEN LogInfo(F_Concat4('found ', SEL(isStartMark,'Intermediate','StartMark'), SEL(isMarkMissing,' OK ',' MISSED '), strMark(pMark:=pMarkSearch))); END_IF  
  
  // searched start, found start (normal start)
  IF isStartMark AND nMarkSelection = 1 THEN   
    IF _pFbMarkDefinition^.nMarks = 1 THEN 
      // only one mark --> TERMINATE + START
      // - start
      SheetStart(pMark:=pMarkSearch);
      IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF  // TERMINATE already after single mark scanned
    ELSE
      // more marks --> START + NEXT
      // - start
      SheetStart(pMark:=pMarkSearch);
      // - next
      nMarkSelection := nMarkSelection + 1;    // next mark
		END_IF

  // search other mark and found start mark (start abort)
  ELSIF isStartMark AND nMarkSelection > 1 THEN
    // terminate(abort) last
    IF nMarkSelection < _pFbMarkDefinition^.nMarks THEN
      LogError('New start mark before last mark detected, missed a mark?');
      bInvalidRepeatLength := TRUE;
    END_IF

    // terminate/abort with new --> TERMINATE + START
    // - start
    SheetStart(pMark:=pMarkSearch);
    
    nMarkSelection := nMarkSelection + 1;    // next mark

  // intermediate marks
  ELSIF NOT isStartMark AND nMarkSelection > 1 THEN
    // search and found other --> NEXT (ev. terminate)
    
    IF _pFbMarkDefinition^.nMarksDetected <= _pFbMarkDefinition^.nMarks THEN
      // - save mark
      _pFbMarkDefinition^.saveMark(pMark:=pMarkSearch);   // save
      // - last mark?
      IF nMarkSelection = _pFbMarkDefinition^.nMarks THEN
        IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF   // stop ct
        nMarkSelection := 1;
      ELSE
        nMarkSelection := SEL(nMarkSelection<_pFbMarkDefinition^.nMarks, 1, nMarkSelection + 1);  // next
      END_IF 
    END_IF
  ELSE
    ;  // invalid mark ingore
	END_IF
  
END_IF

// --- Error Handling
// -- Substrate supervision
(*
nLastX0 := getLastX0();
// - no detected StartMark within some repeats
IF (nC_MaxRepeatsWithoutStart * _fSubstrateLength) < (F_SubPixelToMeter(lPosSubPx:=(nCurrentPos - nPosRepeatSupervision), fResSubPx:=_fResolution)) THEN 
  bNoStartMarkDetected := TRUE;
END_IF
IF nLastX0 <> 0 THEN
  // - no next StartMark recived -> terminate/abort sheet
  IF (nCurrentPos - nLastX0) > (_fSubstrateLength * fC_MaxSubstrateFactor) THEN
    bInvalidRepeatLength := TRUE;
    SheetStop(nNewX0:=0);
  END_IF
  // - missed intermediate mark
  IF pMark^.nId > 1 AND (nCurrentPos - nLastX0) > F_MeterToSubPixel(fPosMeter:=pMark^.fPosX + pMark^.fTrLength + pMark^.fSqLength + fC_MarkLengthMargin, fResoSubPx:=_fResolution) THEN
    pMark^.sState.bSet := FALSE;
    pMark^.sState.bMissed := TRUE;
    pMark^.sState.nPosXReal := 0;
    pMark^.sState.dx := 0;
    pMark^.sState.dy := 0;
    bMissingMarks := TRUE;
    searchForMark := TRUE;
	END_IF

END_IF
*)



// outputs
// _bStartTrig := // set in SheetStart
// _nX0 :=  // set in SheetStart
_bValid := TRUE;
]]></ST>
    </Implementation>
    <Folder Name="I_CameraTrigger" Id="{d101fc83-bd60-457e-82ad-1ca81fc3c1cf}" />
    <Folder Name="I_Sim" Id="{ff6b377e-88a9-44af-8cda-3888841279c7}" />
    <Folder Name="I_StartPosDetect" Id="{1f59ba68-e05b-4e64-bab9-8ffc4daf5201}" />
    <Folder Name="Sim" Id="{c1ece3f2-7bf5-4b5e-8a19-fc5736747d40}" />
    <Method Name="analizeMark" Id="{4b5871d7-90d9-4505-93f6-f899a4e7045c}">
      <Declaration><![CDATA[(*
  Check if mark was detected properly and type matches.
  :returns:  TRUE if valid mark
*)
METHOD PRIVATE analizeMark : BOOL
VAR_INPUT
  pMark           : POINTER TO ST_MarkDefinition;     // mark to search for
  nDetectedPos    : DINT;                             // detected position [SubPx]
  fRealMarkLength : LREAL;                            // real detected mark length [m]
  bMissed         : BOOL;                             // missing mark (but generated)
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;    // a start mark was detected
END_VAR
VAR
  fMarkLengthMin : LREAL;
  fMarkLengthMax : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF
IF pMark^.fHeight = 0 OR pMark^.fTrLength = 0 THEN analizeMark := FALSE; RETURN; END_IF
(*
  Sensor should aligned to the middle of the sensor (fI_MarkHeight / 2)
  With the difference OF the measured length to the normal lenght, the LateralOffset in Y can be calculated
*)

pMark^.sState.nPosXReal := nDetectedPos;          // save detected mark pos (rising in normal, falling in reverse print)
pMark^.sState.fLengthReal := fRealMarkLength;     // apply detected mark length

fMarkLengthMin := pMark^.fSqLength;
fMarkLengthMax := pMark^.fSqLength+pMark^.fTrLength;
// - minimal mark length check
IF fRealMarkLength < fMarkLengthMin THEN
  // mark shorter than defined, ignore detected
  //LogError(F_Concat6('Mark[', TO_STRING(pMark^.nId) ,'] too short ', TO_STRING(fRealMarkLength), '<', TO_STRING(fMarkLengthMin)));
  pMark^.sState.bTooShort := TRUE;
  RETURN; 
END_IF
// - max mark length check
IF fRealMarkLength > (_pFbMarkDefinition^.fMaxLengthStartMark + fC_MarkLengthMargin) THEN
  // mark even longer than longer max size of StartMark
  //LogError(F_Concat4('Mark too long ', TO_STRING(fRealMarkLength), '>', TO_STRING(fMarkLengthMax)));
  pMark^.sState.bToolLong := TRUE;
  RETURN; 
END_IF 

// - dx  (based on sheet begin) dx = current mark position - teached mark position
IF NOT bSim_Mark_Displacement THEN pMark^.sState.dx := getMarkDistanceEffective(pMark:=pMark) - pMark^.fPosX;
ELSE                      pMark^.sState.dx := fSim_Dx_Fix;
END_IF

// - dy
IF NOT bSim_Mark_Displacement THEN pMark^.sState.dy := ((pMark^.sState.fLengthReal - pMark^.fSqLength)/pMark^.fTrLength)*pMark^.fHeight-(pMark^.fHeight/2);
ELSE                      pMark^.sState.dy := fSim_Dy_Fix;
END_IF
IF pMark^.bInvertedX THEN     // if marks are inverted (flipped along x-axis), the correction is inverted
  pMark^.sState.dy := -1*pMark^.sState.dy;
END_IF

// check position qualitiy
pMark^.sState.bInArea := FC_COMPARE_RANGE_PERCENT( 
                                       fI_ValueSet := (pMark^.fHeight / 2)
                                     , fI_ValueActual  := (pMark^.fHeight / 2) + pMark^.sState.dy
                                     , fI_RangePercent := nC_AreaMarkSensorOk);

// type of mark
bStartMark := (fRealMarkLength >= _pFbMarkDefinition^.fMinLengthStartMark);
pMark^.sState.bMissed := bMissed;
pMark^.sState.bSet := NOT bMissed;

analizeMark := pMark^.sState.bSet OR pMark^.sState.bMissed;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="bManualTeach" Id="{df20bc57-11eb-4a4c-bb48-8c48e3ea4239}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[PROPERTY bManualTeach : BOOL
]]></Declaration>
      <Get Name="Get" Id="{e30ba6ac-bdcc-4437-812a-a5d21cb095bd}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bManualTeach := _bCamManualTeachMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{7aab44fb-9a4a-4b83-99ec-1a941d7fbc16}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bCamManualTeachMode := bManualTeach;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bSimEnable" Id="{e3a06385-1c50-475d-9488-8574b26de82a}" FolderPath="I_Sim\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
(*Simulation is enabled set/get*)
PROPERTY bSimEnable : BOOL
]]></Declaration>
      <Get Name="Get" Id="{13f63a9d-022b-4281-9ed8-ef18502f58e2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSimEnable := _bSimEnable;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{9ae33c53-9bbd-4925-8000-b394232e1106}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bSimEnable := bSimEnable;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bStartTrig" Id="{2b535b6f-2cad-40be-8452-e1bd69926871}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A new container detected.
  NOTE: a pulse only
*)
PROPERTY bStartTrig : BOOL
]]></Declaration>
      <Get Name="Get" Id="{79d25c6b-1086-41a3-aef7-a754681e2a5c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bStartTrig := _bStartTrig;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="bValid" Id="{6296e209-5593-4c23-b63e-36af86521efb}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A valid container detected.
*)
PROPERTY bValid : BOOL
]]></Declaration>
      <Get Name="Get" Id="{cbb5fa57-86c7-48e3-9fc1-7b319e18afe2}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bValid := _bValid;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="calcCycleTime" Id="{364210d3-0a32-409e-ab75-099e063e07d8}">
      <Declaration><![CDATA[// cycle time in [s]
METHOD PRIVATE calcCycleTime : LREAL
VAR_INPUT
  tCurrent : T_DCTIME64;
END_VAR
VAR_INST
  tLastTimeStamp : T_DCTIME64 := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calcCycleTime := (TO_LREAL(tCurrent) - TO_LREAL(tLastTimeStamp)) * 1E-9;
tLastTimeStamp  := tCurrent;  // memory timestamp]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disable" Id="{2c4b1c83-79e3-4f6a-980d-819c33124d17}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Disable : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_iActiveCam := 0;
Disable := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{b99e108f-217c-4e29-8c3c-98f284083531}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Enable : BOOL
VAR_INPUT
	iCam	                    : I_CameraTriggerDevice;
  bUseCameraTrigger         : BOOL; //Generate camera trigger
  bUseCameraTriggerFeedback : BOOL; //Use feedback as trigger?
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iCam = 0 THEN
  Enable := FALSE;
  LogError('setCam failed: invalid reference');
ELSE
  _iActiveCam := iCam;
  Enable     := TRUE;

  // save constant settings
  _bUseCameraTrigger := bUseCameraTrigger;
  _bUseCameraTriggerFeedback := bUseCameraTriggerFeedback;
  
  IF _bUseCameraTrigger OR _bUseCameraTriggerFeedback THEN
    LogWarning('Enable: Camera Trigger output/feedback not yet supported');
	END_IF
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Property Name="fSubstrateGap" Id="{dddfda1d-9510-4f08-8c3b-41448ad48eb9}" FolderPath="Sim\">
      <Declaration><![CDATA[PROPERTY fSubstrateGap : LREAL]]></Declaration>
      <Set Name="Set" Id="{3793e14d-a171-461a-b80b-3095c58172b7}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fSubstrateGap := fSubstrateGap;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="GenMark" Id="{41babaf5-7b19-4ac6-9251-9045583d94dd}">
      <Declaration><![CDATA[(*
  Generate detected marks.
*)
METHOD PRIVATE GenMark : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  n : DINT;
  nImageLength : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

nImageLength := F_MeterToSubPixel(fPosMeter:=_fSubstrateLength + _fSubstrateGap, fResoSubPx:=_fResolution);
IF nImageLength = 0 THEN RETURN; END_IF


IF NOT bMarkOn THEN  // start new mark

  // create rising edge
  IF pMark^.nId = 1 THEN          // a start mark
    // wait for next StartPosition
    IF nCurrentPos >= nLastGeneratedStartMarkPosition + nImageLength THEN

      // fix bigger gaps than next sheet (always try to start repeats at a multiple of last repeat)
      IF (nCurrentPos - nLastGeneratedStartMarkPosition) / nImageLength > 2 THEN
        nLastGeneratedStartMarkPosition := nLastGeneratedStartMarkPosition + ((((nCurrentPos - nLastGeneratedStartMarkPosition) / nImageLength) -1) * nImageLength);  // correct to one sheet before 
			END_IF 
      
      nLastGeneratedStartMarkPosition := nLastGeneratedStartMarkPosition + nImageLength;      // save last repeat position   
      
      pMark^.sState.nPosXReal := nLastGeneratedStartMarkPosition + F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution); // mark detected position
      pMark^.sState.fLengthReal := 0;
      pMark^.sState.dx := 0;
      pMark^.sState.dy := 0;
      pMark^.sState.bInArea := TRUE;
      pMark^.sState.bSet := TRUE;
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= pMark^.fPosX THEN
     
      pMark^.sState.nPosXReal := nLastGeneratedStartMarkPosition + F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution); // 
      pMark^.sState.fLengthReal := 0;
      pMark^.sState.dx := 0;
      pMark^.sState.dy := 0;
      pMark^.sState.bInArea := TRUE;
      pMark^.sState.bSet := TRUE;
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // end mark after one dycle
  bMarkOn := FALSE;
  IF pMark^.nId = 1 THEN bStartMark := TRUE; END_IF  
  GenMark := TRUE;      // reset after one cycle active
  SaveToMarkHistory(pMark:=pMark);    // Save to mark history
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getExactPosition" Id="{ab38530b-e976-42c4-b85f-34138aa2af23}">
      <Declaration><![CDATA[// calculate the exact detected position
// :returns: the X0 position
METHOD PRIVATE getExactPosition : DINT
VAR_INPUT
  tNow              : T_DCTIME64;    // current system time
  tEdge             : T_DCTIME64;   // detected time
  nPos              : DINT;          // current (encoder) position at the current time
  fSpeed            : LREAL;       // current speed for the timestamped position correction calculation
END_VAR
VAR
  fCurrentTimeStamp : LREAL;
  fSensor_TimeStamp : LREAL;
  nDeltaPosition    : DINT;       // distance [SubPx]
  fDeltaDistance    : LREAL;      // Distance that the substrate moved between the detection and the treatment of the information
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _bSimEnable THEN // calculation like DMAX for simulation mode
  fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tNowDc), ULINT_TO_ULARGE(tEdge))) * 1E-9 * fSpeed;
  getExactPosition := nPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=_fResolution);
  RETURN; 
END_IF

// Calculate the original position back from timestamp input trigger (compensated)
fCurrentTimeStamp  := (ULINT_TO_LREAL(tNow) - (GVL_WEU.nC_CurrentTimeStampComp * 1_000)) / 1_000_000.0; // [ms]
fSensor_TimeStamp := (ULINT_TO_LREAL(tEdge) - (GVL_WEU.nC_SensorTimeStampComp  * 1_000)) / 1_000_000.0; // [ms]

// Treatment of the information
fDeltaDistance   := (fCurrentTimeStamp - fSensor_TimeStamp) * 0.001 * fSpeed;	      // Distance in pulses that the substrate has traveled between the sensor detection and the PLC treatment
nDeltaPosition := FC_LREAL_TO_DINT(fDeltaDistance * (1 / (0.0254 / _fResolution)));   // 1/1px*)	(* Travel of the substrate between the time of acquisition and the time of treatment
getExactPosition := nPos - nDeltaPosition;	                                          // Position where the sheet has been detected
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getLastX0" Id="{e214bad2-eb1a-4fe3-9577-532f91362ba1}">
      <Declaration><![CDATA[(*
  Get X0 from detected start mark
*)
METHOD PRIVATE getLastX0 : DINT
VAR
  pLastStartMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pLastStartMark := _pFbMarkDefinition^.pLastStartMark;
IF pLastStartMark <> 0 THEN
  getLastX0 := pLastStartMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pLastStartMark^.fPosX, fResoSubPx:=_fResolution);
END_IF
 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="getMarkDistanceEffective" Id="{68edcd73-62a6-4ea7-86a3-074f09dbf0e3}">
      <Declaration><![CDATA[(*
  Calculate effective distance of mark to X0 [m]
*)
METHOD PRIVATE getMarkDistanceEffective : LREAL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  pFirstMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

IF pMark^.nId = 1 THEN 
  getMarkDistanceEffective := pMark^.fPosX;
ELSE
  pFirstMark := _pFbMarkDefinition^.getMark(nIdx:=1);
  IF pFirstMark <> 0 THEN
    // real distance between this mark and start mark + fPosX of start mark
    getMarkDistanceEffective := pFirstMark^.fPosX + F_SubPixelToMeter(lPosSubPx:=pMark^.sState.nPosXReal - pFirstMark^.sState.nPosXReal, fResSubPx:=_fResolution);
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{8b90af5b-46dd-4259-9012-558a5204768a}">
      <Declaration><![CDATA[METHOD Init
VAR_INPUT
  fPrintResolution      : LREAL := 600;         // print(head) resolution in [dpi]
  fSubPxResolution      : LREAL := 32;          // SubPixel resolution [SubPx], resolution factor (fI_PrintResolution*fI_SubPxResolution=>Output resolution)
  pFbMarkDefinition     : POINTER TO FB_MarkDefinition;
END_VAR
VAR
  i : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fPrintResolution = 0 OR fSubPxResolution = 0 OR pFbMarkDefinition = 0 THEN LogError('Init: invalid parameter'); RETURN; END_IF

_fResolution := fPrintResolution * fSubPxResolution;
_pFbMarkDefinition:= pFbMarkDefinition;

Reset();

bInitOk := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="manualTrigger" Id="{7e0ae2df-59c6-48e9-9f8b-bf72ee5c1a29}" FolderPath="Sim\">
      <Declaration><![CDATA[METHOD PRIVATE manualTrigger : BOOL
VAR_INST
  rfTrig_ManuTrigger : RF_TRIG;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rfTrig_ManuTrigger(CLK:=bManualTrigger);

IF rfTrig_ManuTrigger.RT THEN
  LogWarning('manualTrigger not yet implemented');
END_IF

manualTrigger := rfTrig_ManuTrigger.RT;]]></ST>
      </Implementation>
    </Method>
    <Property Name="nStartPositionX0" Id="{41d198fe-0cfa-476e-a8f1-ad17439d80dc}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  Detected start position X0 (absolute) in [SubPx].
*)
PROPERTY nStartPositionX0 : DINT
]]></Declaration>
      <Get Name="Get" Id="{aef83ef7-0702-4562-8ef9-8b869fc94e14}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nStartPositionX0 := _nX0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Reset" Id="{0ced2272-e170-419a-86b1-b32737b9a4f2}">
      <Declaration><![CDATA[(*
  Reset internal state and all marks
*)
METHOD Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN; END_IF

_bValid := FALSE;
_bStartTrig := FALSE;
nMarkSelection := 1; // start mark
bDetectionRunning := FALSE;
nPosRepeatSupervision := nCurrentPos;       // sample activated detection position

// reset camera (release if one is selected)
IF bSheetActive THEN
  IF _iActiveCam <> 0 THEN _iActiveCam.CamTriggerDone(); END_IF   // notify an done/abort
END_IF
_pFbMarkDefinition^.ResetMarkStates();  // reset detected marks
bSheetActive := FALSE;
bResetDetection := TRUE;        // reset checkForMark() state machine

// reset errors
nCtrSensorDetectError := 0;
nCtrIgnoredMarks := 0;
bNoStartMarkDetected := FALSE;
bInvalidRepeatLength := FALSE;
bInvalidMarkDetected := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SaveToMarkHistory" Id="{0a4522c1-59b9-4bac-8aaa-4ce9ef40b7b7}">
      <Declaration><![CDATA[METHOD PRIVATE SaveToMarkHistory
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO nC_HistorySize-1 DO sMarkHistory[i].sView.colorFill := 16#FFE2DDDB; END_FOR   // clear selection
nMarkHistoryCt := (nMarkHistoryCt + 1) MOD nC_HistorySize;
sMarkHistory[nMarkHistoryCt] := pMark^;
sMarkHistory[nMarkHistoryCt].sView.colorFill := 16#FF90EE90;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="searchForMark" Id="{1ae59a69-2ea0-4490-923c-1411513ca101}">
      <Declaration><![CDATA[(*
  Poll for sensor triggers and marks.
  :return: true if a mark was detected
*)
METHOD PRIVATE searchForMark : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;             // mark to search for
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;          // a start mark was detected
  bMissing   : BOOL;          // mark was missing (and generated)
END_VAR
VAR
  nAbortMarkAfterDist : DINT;     // max. length to search for mark end before aborting this mark [SubPx]
  nLastX0 : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF
IF bResetDetection THEN bResetDetection := FALSE;  // reset methods internal states
  bMarkStartDetected := FALSE; bMarkEndDetected := FALSE;
  bInhibitTrigger := FALSE; 
  bMissing := FALSE;
END_IF

// --- Simulation for testing
IF _bSimEnable AND _nSimMode = 0 THEN   // simulate some marks for testing
  searchForMark := SimMarks(pMark:=pMark, bStartMark=>bStartMark);
  RETURN; 
  
// --- Generate masks if none are available
ELSIF pMark^.bVirtual THEN    // generate marks (for NoMark mode)
  searchForMark := GenMark(pMark:=pMark, bStartMark=>bStartMark);
  RETURN;
END_IF

// simulate sensor
IF _bSimEnable AND _nSimMode = 1 THEN
  SimSensor(pMark:=pMark, bSensorSimulationSignal=>bSensorSignal, tSensorRising=>tSensorRisingTimeStamp, tSensorFalling=>tSensorFallingTimeStamp);
END_IF


// --- Use sensor
rfEdgeSensor(CLK:=bSensorSignal);   // edge detection
nAbortMarkAfterDist := F_MeterToSubPixel(fPosMeter:=pMark^.fTrLength + pMark^.fSqLength + fC_MarkLengthMargin + fCycleTime*fCurrentSpeed, fResoSubPx:=_fResolution); // mark len + margin + one cycle

// --- Inhibit Control (filters wrong placed intermediate triggers/marks)



// -- rising edge detection
IF rfEdgeSensor.RT AND NOT bInhibitTrigger THEN
  tRisingEdge := tSensorRisingTimeStamp;   // sample input
  nRisingPos  := getExactPosition(tNow:=tNowDc, tEdge:=tRisingEdge, nPos:=nCurrentPos, fSpeed:=fCurrentSpeed);   // position where mark was seen
  bMarkStartDetected := TRUE;
END_IF;
// -- falling edge detection
IF rfEdgeSensor.FT AND NOT bInhibitTrigger THEN
  // falling edge
  tFallingEdge := tSensorFallingTimeStamp;
  nFallingPos := getExactPosition(tNow:=tNowDc, tEdge:=tFallingEdge, nPos:=nCurrentPos, fSpeed:=fCurrentSpeed);   // position where mark was seen
  IF NOT bMarkStartDetected THEN
    // ignore
    nCtrSensorDetectError := nCtrSensorDetectError + 1;
    LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='Missing rising trigger edge before falling edge');
    bResetDetection := TRUE;
  ELSE
    // ok                    
    bMarkEndDetected := TRUE; 
  END_IF
END_IF
// - abort search for falling edge
IF bMarkStartDetected AND (nCurrentPos - nRisingPos) > nAbortMarkAfterDist THEN      // abort after waiting for end
  // Abort - Expected falling edge missed
  nCtrSensorDetectError := nCtrSensorDetectError + 1;
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('Mark end not given after [SubPx]:', TO_STRING(nAbortMarkAfterDist)));
  bResetDetection := TRUE;   // reset detection logic
END_IF;

// mark evaluation 
IF bMarkStartDetected AND bMarkEndDetected THEN
  // mark found
  
  // check mark & calculate offsets
  fMarkDuration := ABS(ULINT_TO_LREAL(tFallingEdge) - ULINT_TO_LREAL(tRisingEdge));		// Calculate how long the signal was ON
  // define and check mark
  IF analizeMark( pMark:=pMark,
                  nDetectedPos:=SEL(bReverse, nRisingPos, nFallingPos),
                  fRealMarkLength:=fMarkDuration * fCurrentSpeed * 0.000_000_001,
                  bMissed:=FALSE,
                  bStartMark => bStartMark,
               )
  THEN
    // Checks 
    IF bStartMark AND pMark^.nId <> 1 THEN    // Did we really search a StartMark?
      LogWarning(F_Concat2('StartMark found while searching for intermediate, ignored', strMark(pMark:=pMark)));
      bInvalidRepeatLength := TRUE;
      nCtrIgnoredMarks := nCtrIgnoredMarks + 1;
    ELSE
      // OK
      bInvalidMarkDetected := FALSE;      // reset error with next ok mark
      SaveToMarkHistory(pMark:=pMark);    // Save to mark history
      searchForMark := TRUE;              // a valid mark detected
		END_IF
  ELSE
    // no valid mark
    nCtrIgnoredMarks := nCtrIgnoredMarks + 1;
	END_IF
  
  bResetDetection := TRUE;   // reset detection logic
END_IF

// generate missed marks
IF _pFbMarkDefinition^.nMarksDetected > 1 AND _pFbMarkDefinition^.nMarksDetected < _pFbMarkDefinition^.nMarks THEN

  nLastX0 := getLastX0();
  IF F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nLastX0, fResSubPx:=_fResolution) > (pMark^.fPosX + pMark^.fTrLength + pMark^.fSqLength + fC_MarkLengthMargin) THEN
    analizeMark(
      pMark := pMark, 
      nDetectedPos := nLastX0 + F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution),                                              // don't know
      fRealMarkLength := pMark^.fSqLength + (pMark^.fTrLength / 2),   // default length
      bMissed := TRUE
    );
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetSubstrateLength" Id="{c2eca7fa-618a-4a26-859a-7a8c8d16b893}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD SetSubstrateLength
VAR_INPUT
  fSubstrateLength : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN;END_IF;

(*reduced by margin (for endless mode with potential smaller printed repetition)*)
_fSubstrateLength := fSubstrateLength;
//_nSubstrateLength := F_MeterToSubPixel(fPosMeter:=_fSubstrateLength, fResoSubPx:=_fResolution);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStart" Id="{f3f7c5cf-7e12-4918-a100-a15504ddde77}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStart
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  sMarkBackup : ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_nX0 := pMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution);
_bStartTrig := TRUE;
bDetectionRunning := TRUE;
bNoStartMarkDetected := FALSE;
bInvalidRepeatLength := FALSE;

// (force) terminate a sheet/repeat
IF bSheetActive THEN 
  IF _bVerbose THEN LogInfo(F_Concat2('Terminate sheet/repeat with new Start Mark', '')); END_IF
  sMarkBackup := pMark^;   // push 
  SheetStop(nNewX0:=_nX0);
  pMark^:= sMarkBackup;    // pop
END_IF

IF _bVerbose THEN LogInfo(F_Concat2('SheetStart at X0=', TO_STRING(_nX0))); END_IF

// save (start) mark
_pFbMarkDefinition^.saveMark(pMark:=pMark);

// trigger camera
IF _iActiveCam<>0 THEN _iActiveCam.CamTrigger(bOk:=TRUE, nPos:=_nX0, nPosDeviation:=0, nX0:=_nX0); END_IF

// save for supervision
nPosRepeatSupervision := _nX0;

bSheetActive := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStop" Id="{1e821371-9a32-40bd-88f3-20dd008c1594}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStop
VAR_INPUT
  nNewX0 : DINT;   // new detected X0
END_VAR
VAR
  i : UDINT;
  pLastMark : POINTER TO ST_MarkDefinition;
  fD : LREAL;
  fSLen : LREAL;
  nDetectedX0 : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// - terminate
IF _bVerbose THEN LogInfo(F_Concat2('SheetStop()', '')); END_IF

fSLen := _fSubstrateLength;  // (default) original length

// calculate effective sheet length
nDetectedX0 := getLastX0();   // get sampled X0
IF nNewX0 <> 0 AND nDetectedX0 <> 0 THEN
  // real diff between two starts
  fD := F_SubPixelToMeter(lPosSubPx:=nNewX0 - nDetectedX0, fResSubPx:=_fResolution);
  IF fD < (_fSubstrateLength * fC_MaxSubstrateFactor) THEN
    fSLen := fD;
  END_IF 
ELSIF nNewX0 = 0 AND _pFbMarkDefinition^.nMarksDetected > 1 THEN
  // calculate based on last detected mark (a strech factor)
  pLastMark:= _pFbMarkDefinition^.getMark(nIdx:=0);     // get last available mark
  fD := getMarkDistanceEffective(pMark:=pLastMark); 
  fSLen := (pLastMark^.fPosX/SEL(fD<>0, pLastMark^.fPosX, fD)) * _fSubstrateLength; // estimate real length with last mark
END_IF
_fSubstrateLengthEffective := fSLen;


// debug history
FOR i:=0 TO nC_HistorySize-1 DO sRepeatHistory[i].bSelected := FALSE; END_FOR   // clear selection
nRepeatCt := (nRepeatCt + 1) MOD nC_HistorySize;
sRepeatHistory[nRepeatCt].bSelected       := TRUE;
sRepeatHistory[nRepeatCt].nIndex          := nRepeatCt+1;
sRepeatHistory[nRepeatCt].nX0             := nDetectedX0;
sRepeatHistory[nRepeatCt].fLen            := _fSubstrateLength;
sRepeatHistory[nRepeatCt].fLenEffective   := _fSubstrateLengthEffective;
sRepeatHistory[nRepeatCt].fLenDiff        := _fSubstrateLengthEffective - _fSubstrateLength;
sRepeatHistory[nRepeatCt].bLenNotInRange  := bInvalidRepeatLength;
sRepeatHistory[nRepeatCt].bInvalidIngoredMarks := bInvalidMarkDetected;
sRepeatHistory[nRepeatCt].bMissingMarks   := bMissingMarks;


IF _iActiveCam<>0 THEN _iActiveCam.CamTriggerDone(); END_IF 
_pFbMarkDefinition^.ResetMarkStates();

bSheetActive := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimMarks" Id="{ba4ae033-5970-4d7b-9d6a-aa07cd6f3539}" FolderPath="Sim\">
      <Declaration><![CDATA[METHOD PRIVATE SimMarks : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  nMarkStarted : DINT;
  fStartMarkOffset : LREAL;
  rand : DRAND;
  rlrand : LREAL;
  l : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

// when sim enabled AND auto-trigger then create a StartMark after every sheet/repeat length
//  then generate every following intermediate mark with a given length

IF NOT bMarkOn THEN  // start new mark
  // create rising edge
  IF pMark^.nId = 1 THEN
    // wait for next StartPosition
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= _fSubstrateLength + _fSubstrateGap THEN
      nLastGeneratedStartMarkPosition := nCurrentPos;      // save start mark pos
      fStartMarkOffset := pMark^.fPosX;   // save start mark displacement from X0
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= pMark^.fPosX - fStartMarkOffset THEN
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // create falling edge
  IF (nCurrentPos - nMarkStarted) > l THEN
    rand(Seed:=13, Num=>rlrand);  // TODO: find a right scale 
    analizeMark(
      pMark:=pMark, 
      nDetectedPos:=nMarkStarted, 
      fRealMarkLength:=F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nMarkStarted, fResSubPx:=_fResolution),
      bMissed:=FALSE
    );
    bMarkOn := FALSE;
    If pMark^.nId = 1 THEN bStartMark := TRUE; END_IF
    SimMarks := TRUE;    // mark done
    SaveToMarkHistory(pMark:=pMark);    // Save to mark history
  END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimSensor" Id="{40264f83-47bf-485c-9dad-a8d0b7e9a300}" FolderPath="Sim\">
      <Declaration><![CDATA[// simulate marks with sensor simulation
METHOD PRIVATE SimSensor
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  bSensorSimulationSignal : BOOL;
  tSensorRising           : T_DCTIME64;
  tSensorFalling          : T_DCTIME64;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  nMarkStarted : DINT;
  fStartMarkOffset : LREAL;
  rand : DRAND;
  rlrand : LREAL;
  l : DINT;
  tRising, tFalling : T_DCTIME64;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

IF NOT bMarkOn THEN  // start new mark
  // create rising edge
  IF pMark^.nId = 1 THEN
    // wait for next StartPosition
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= _fSubstrateLength + _fSubstrateGap THEN
      nLastGeneratedStartMarkPosition := nCurrentPos;      // save start mark pos
      fStartMarkOffset := pMark^.fPosX;   // save start mark displacement from X0
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      tRising := tNowDc;
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= pMark^.fPosX - fStartMarkOffset THEN
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixel(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      tRising := tNowDc;
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // create falling edge
  IF (nCurrentPos - nMarkStarted) > l THEN
    rand(Seed:=13, Num=>rlrand);  // TODO: find a right scale 
    tFalling := tNowDc;
    bMarkOn := FALSE;
  END_IF
END_IF

bSensorSimulationSignal := bMarkOn;
tSensorRising := tRising;
tSensorFalling := tFalling;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="strMark" Id="{79a67c19-4fa5-4875-ac66-bba24bae999d}">
      <Declaration><![CDATA[METHOD strMark : T_MaxString
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_INST
  fbStrFormat : FB_FormatString;
END_VAR
VAR
  IdFormatted : STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbStrFormat(sFormat:='%.2d', arg1:=F_DINT(pMark^.nId), sOut=>IdFormatted);
strMark := F_Concat6(
  F_Concat2('Id:',   IdFormatted),
  F_Concat2(' Set:', SEL(pMark^.sState.bSet,'0','1')),
  F_Concat2(' posX:', LREAL_TO_FMTSTR( pMark^.fPosX, 5, TRUE )),
  F_Concat2(' posY:', LREAL_TO_FMTSTR( pMark^.fPosY, 5, TRUE )),
  F_Concat2(' dx:', LREAL_TO_FMTSTR( pMark^.sState.dx, 5, TRUE )),
  F_Concat2(' dy:', LREAL_TO_FMTSTR( pMark^.sState.dy, 5, TRUE )),
);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkDetection_v2">
      <LineId Id="12337" Count="25" />
      <LineId Id="12720" Count="0" />
      <LineId Id="12363" Count="0" />
      <LineId Id="12725" Count="1" />
      <LineId Id="12721" Count="0" />
      <LineId Id="12364" Count="19" />
      <LineId Id="12895" Count="0" />
      <LineId Id="12385" Count="1" />
      <LineId Id="12389" Count="14" />
      <LineId Id="12406" Count="26" />
      <LineId Id="12447" Count="1" />
      <LineId Id="12433" Count="2" />
      <LineId Id="12441" Count="0" />
      <LineId Id="12867" Count="1" />
      <LineId Id="12892" Count="0" />
      <LineId Id="12869" Count="21" />
      <LineId Id="12864" Count="0" />
      <LineId Id="12891" Count="0" />
      <LineId Id="12865" Count="1" />
      <LineId Id="12442" Count="4" />
      <LineId Id="6884" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.analizeMark">
      <LineId Id="173" Count="1" />
      <LineId Id="176" Count="2" />
      <LineId Id="180" Count="0" />
      <LineId Id="296" Count="1" />
      <LineId Id="295" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="234" Count="0" />
      <LineId Id="223" Count="1" />
      <LineId Id="294" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="345" Count="0" />
      <LineId Id="260" Count="1" />
      <LineId Id="225" Count="0" />
      <LineId Id="227" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="291" Count="1" />
      <LineId Id="281" Count="0" />
      <LineId Id="344" Count="0" />
      <LineId Id="184" Count="1" />
      <LineId Id="316" Count="1" />
      <LineId Id="319" Count="0" />
      <LineId Id="187" Count="1" />
      <LineId Id="320" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="194" Count="8" />
      <LineId Id="365" Count="0" />
      <LineId Id="363" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bManualTeach.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bManualTeach.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bSimEnable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bSimEnable.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bStartTrig.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.bValid.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.calcCycleTime">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.Disable">
      <LineId Id="4" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.Enable">
      <LineId Id="31" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="70" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.fSubstrateGap.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.GenMark">
      <LineId Id="441" Count="46" />
      <LineId Id="503" Count="0" />
      <LineId Id="488" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.getExactPosition">
      <LineId Id="156" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="138" Count="7" />
      <LineId Id="39" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.getLastX0">
      <LineId Id="16" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.getMarkDistanceEffective">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.Init">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.manualTrigger">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.nStartPositionX0.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.Reset">
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="25" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="55" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SaveToMarkHistory">
      <LineId Id="7" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.searchForMark">
      <LineId Id="626" Count="16" />
      <LineId Id="785" Count="0" />
      <LineId Id="784" Count="0" />
      <LineId Id="786" Count="2" />
      <LineId Id="643" Count="0" />
      <LineId Id="769" Count="0" />
      <LineId Id="645" Count="2" />
      <LineId Id="721" Count="0" />
      <LineId Id="723" Count="1" />
      <LineId Id="722" Count="0" />
      <LineId Id="708" Count="0" />
      <LineId Id="649" Count="14" />
      <LineId Id="715" Count="0" />
      <LineId Id="664" Count="10" />
      <LineId Id="676" Count="11" />
      <LineId Id="817" Count="0" />
      <LineId Id="690" Count="2" />
      <LineId Id="735" Count="1" />
      <LineId Id="763" Count="0" />
      <LineId Id="760" Count="0" />
      <LineId Id="826" Count="0" />
      <LineId Id="764" Count="0" />
      <LineId Id="761" Count="0" />
      <LineId Id="767" Count="0" />
      <LineId Id="762" Count="0" />
      <LineId Id="768" Count="0" />
      <LineId Id="747" Count="0" />
      <LineId Id="694" Count="0" />
      <LineId Id="726" Count="0" />
      <LineId Id="825" Count="0" />
      <LineId Id="698" Count="0" />
      <LineId Id="702" Count="2" />
      <LineId Id="821" Count="0" />
      <LineId Id="808" Count="0" />
      <LineId Id="807" Count="0" />
      <LineId Id="820" Count="0" />
      <LineId Id="819" Count="0" />
      <LineId Id="809" Count="0" />
      <LineId Id="811" Count="0" />
      <LineId Id="823" Count="0" />
      <LineId Id="812" Count="1" />
      <LineId Id="815" Count="0" />
      <LineId Id="814" Count="0" />
      <LineId Id="824" Count="0" />
      <LineId Id="810" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SetSubstrateLength">
      <LineId Id="8" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SheetStart">
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="79" Count="2" />
      <LineId Id="45" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="48" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SheetStop">
      <LineId Id="54" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="59" Count="2" />
      <LineId Id="73" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="63" Count="5" />
      <LineId Id="110" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="149" Count="2" />
      <LineId Id="164" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="69" Count="3" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SimMarks">
      <LineId Id="28" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="159" Count="2" />
      <LineId Id="163" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.SimSensor">
      <LineId Id="17" Count="0" />
      <LineId Id="21" Count="8" />
      <LineId Id="31" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="32" Count="5" />
      <LineId Id="39" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="40" Count="7" />
      <LineId Id="99" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="94" Count="1" />
      <LineId Id="60" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection_v2.strMark">
      <LineId Id="25" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_EffectiveEncoderResolutionDetection" Id="{172ff757-0f60-4a20-baa8-40d4b6b6387f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_EffectiveEncoderResolutionDetection EXTENDS FB_Commons
VAR_INPUT
  (*EL1252*)
  bIKp_MarkTrigger01    AT%I* : BOOL;        // First  mark sensor - Trigger
  tIKp_TimeStampPos01   AT%I* : T_DCTIME64;  // First  mark sensor - RisingEdge  @EL1252
  tIKn_TimeStampNeg01   AT%I* : T_DCTIME64;  // First  mark sensor - FallingEdge @EL1252
  bIKp_MarkTrigger02    AT%I* : BOOL;        // Second mark sensor - Trigger
  tIKp_TimeStampPos02   AT%I* : T_DCTIME64;  // Second mark sensor - RisingEdge  @EL1252
  tIKn_TimeStampNeg02   AT%I* : T_DCTIME64;  // Second mark sensor - FallingEdge @EL1252
  nPulse                      : DINT;        // encoder pulse input
  nDisInPulseFilterSz         : UDINT;       // mav filter size for measured distance in encoder steps (from machine) 
    
  // settings
  fCurrentResolution          : LREAL;       // current used resolution (given from machine), encoder step size
  fEncoderPulseDistMin        : LREAL;       // [pulse] defines the min sensor distance in pulse, range minimum
  fEncoderPulseDistMax        : LREAL;       // [pulse] defines the max sensor distance in pulse, range maximum
  fMinMarkLength              : LREAL:=2000; // [um] minimal mark lenght to accept a measurement
  fMaxMarkLength              : LREAL:=6000; // [um] maximal mark lenght to accept a measurement
END_VAR
VAR_OUTPUT
  bUpdate                     : BOOL;        // a valid new measurment
  fDisInPulse                 : LREAL;       // disntance in encoder pulse
END_VAR
VAR
  bInitOk                     : BOOL;        // initialized
  fSpeed                      : LREAL;       // current encoder speed [pulse/s]
  fbMark1,fbMark2             : RF_TRIG;     // edge detection
  bMeasurementActive          : BOOL;        // a measurement started
  nMeasurementCounter         : UDINT;       // counter for measurements
  nCurrentDistActive          : DINT;        // current distance during active measurement
  bVerbose                    : BOOL;
  // errors
  bLower, bHigher, bAborted   : BOOL;        // ui errors
  bMarkInvalidLength_S1, bMarkInvalidLenght_S2 : BOOL; // detected marks too short or too long
  nMarkLength_S1, nMarkLength_S2 : UDINT;    // mark length measured in [um]
  
  // time calculations
  tNowDc                      : T_DCTIME64;  // Get Current Timestamp (now
  fCycleTime                  : LREAL;       // Current calculated cycle time [s]

  // position
  nPulse_mem                  : DINT;        // Encoder pulse of previous cycles
  fDistMeasured               : LREAL;       // distance measured [pulse]
  fbFilterMavDisInPulse       : FB_FILTER_MAV; // Moving everage filter
  fbFilterMavSpeed            : FB_FILTER_MAV; // Moving everage filter
  
  // helper measurement
  nPosStart, nPosEnd : DINT;                 // encoder positions detectec (exact by trigger, timestamp and speed based approximation)
  nPosFalling1, nPosFalling2 : DINT;         // exact position in [pulse]
  bRising_S1, bFalling_S1, bRising_S2, bFalling_S2 : BOOL;    // sensor edge detection
  
  // view
  bSim : BOOL;
  nPulseSim : DINT;
END_VAR
VAR PERSISTENT
  nSpeedFilterSz              : UINT := 1;      // speed - moving average filter size
END_VAR
VAR CONSTANT
  nC_MinMarkLength            : LREAL := 2_000; // min. mark length in [um]
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// check & correct parameter
IF NOT bInitOk THEN RETURN; END_IF;

bUpdate := FALSE;

// time caluclations
tNowDc := F_GetCurDcTaskTime64();                  // current dc time (most accurate time stamp we have)
fCycleTime := calcCycleTime(tCurrent:=tNowDc);     // calculate cycle time of this fb
// input edge detection
fbMark1(CLK:=bIKp_MarkTrigger01);
fbMark2(CLK:=bIKp_MarkTrigger02);

// simulation
IF bSim THEN
  nPulseSim := nPulseSim + 1;
  nPulse := nPulseSim;
  bVerbose:=bSim;
  IF fbMark1.RT THEN tIKp_TimeStampPos01 := tNowDc; END_IF
  IF fbMark1.FT THEN tIKn_TimeStampNeg01 := tNowDc; END_IF
  IF fbMark2.RT THEN tIKp_TimeStampPos02 := tNowDc; END_IF
  IF fbMark2.FT THEN tIKn_TimeStampNeg02 := tNowDc; END_IF
END_IF


// speed calculation
fbFilterMavSpeed(fI_Input:=(nPulse - nPulse_mem)/fCycleTime, iI_NbInputs:=LIMIT(1, nSpeedFilterSz, fbFilterMavSpeed.cL_BUFFER_MAX));
fSpeed := fbFilterMavSpeed.fO_OutputMav;
nPulse_mem := nPulse;

measure(bUpdate=>bUpdate, fEncoderDistance=>fDistMeasured);
IF bUpdate THEN
  // check range (given from machine)
  bHigher := SEL(fDistMeasured > fEncoderPulseDistMax, FALSE, TRUE);  IF bVerbose AND bHigher THEN LogWarning('Measured distance in pulse LONGER than max range'); END_IF
  bLower  := SEL(fDistMeasured < fEncoderPulseDistMin, FALSE, TRUE);  IF bVerbose AND bLower  THEN LogWarning('Measured distance in pulse SHORTER than min range'); END_IF

  IF NOT bHigher AND NOT bLower THEN  
    // measurement ok
    fbFilterMavDisInPulse(fI_Input:=fDistMeasured, iI_NbInputs:=TO_UINT(LIMIT(1, nDisInPulseFilterSz, fbFilterMavDisInPulse.cL_BUFFER_MAX))); // moving average filter
    fDisInPulse := fbFilterMavDisInPulse.fO_OutputMav;
  END_IF
  
  nMeasurementCounter := (nMeasurementCounter + 1) MOD 1000;  // limit to 0-1000
END_IF
]]></ST>
    </Implementation>
    <Method Name="calcCycleTime" Id="{d0932db0-858d-4f52-84ae-fb96799c2d8c}">
      <Declaration><![CDATA[METHOD PRIVATE calcCycleTime : LREAL
VAR_INPUT
  tCurrent : T_DCTIME64;
END_VAR
VAR_INST
  tLastTimeStamp : T_DCTIME64 := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calcCycleTime := (TO_LREAL(tCurrent) - TO_LREAL(tLastTimeStamp)) * 1E-9;
tLastTimeStamp  := tCurrent;  // memory timestamp]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkMarkLength" Id="{a7413c46-e6e0-4347-b06a-9059e8a70b2c}">
      <Declaration><![CDATA[METHOD PRIVATE checkMarkLength : BOOL
VAR_INPUT
  nRef : DINT;
  nOther : DINT;
END_VAR
VAR_OUTPUT
  nLen : DINT;  // mark length in pulse
END_VAR
VAR
  fMarkLen : LREAL;  // [um]
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fCurrentResolution = 0 THEN RETURN; END_IF

// pulse elapsed * resolution [pulse/um] => pos in [um]
nLen := ABS(nOther - nRef);
fMarkLen := nLen * fCurrentResolution;
IF fMarkLen > fMinMarkLength AND fMarkLen < fMaxMarkLength THEN
  // mark within spec
  checkMarkLength := TRUE;
ELSE
  IF bVerbose THEN LogWarning(F_Concat5('Mark length invalid: ', TO_STRING(fMarkLen), 'um', ' too short or too long', '')); END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getExactPosition" Id="{64c83f4e-2f90-4829-a9ba-519450c0af9d}">
      <Declaration><![CDATA[METHOD PRIVATE getExactPosition : DINT
VAR_INPUT
  tNow : T_DCTIME64;    // current system time
  nPos : DINT;          // current (encoder) position at the current time
  tEdge : T_DCTIME64;   // detected time
  fSpeed : LREAL;       // current speed
END_VAR
VAR
  fCurrentTimeStamp : LREAL;
  fSensor_TimeStamp : LREAL;
  nDeltaPosition    : DINT;       // distance [SubPx]
  fDeltaDistance    : LREAL;      // Distance that the substrate moved between the detection and the treatment of the information
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fCurrentResolution = 0 THEN RETURN; END_IF

//fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tNowDc), ULINT_TO_ULARGE(tEdge))) * 1E-9 * fSpeed;
//getExactPosition := nPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=fCurrentResolution);   

// Calculate the original position in our position domain
fCurrentTimeStamp  := (ULINT_TO_LREAL(tNow) - (GVL_WEU.nC_CurrentTimeStampComp * 1_000)) / 1_000_000.0; // [ms]
fSensor_TimeStamp := (ULINT_TO_LREAL(tEdge) - (GVL_WEU.nC_SensorTimeStampComp  * 1_000)) / 1_000_000.0; // [ms]

// Treatment of the information
fDeltaDistance   := (fCurrentTimeStamp - fSensor_TimeStamp) * 0.001 * fSpeed;	      // Distance in pulses that the substrate has traveled between the sensor detection and the PLC treatment
nDeltaPosition := FC_LREAL_TO_DINT(fDeltaDistance * (1 / (0.0254 / fCurrentResolution)));   // 1/1px*)	(* Travel of the substrate between the time of acquisition and the time of treatment
getExactPosition := nPos - nDeltaPosition;	                                          // Position where the sheet has been detected]]></ST>
      </Implementation>
    </Method>
    <Method Name="getMarkLength" Id="{59de4153-f433-43c2-84a9-02f391a18c25}">
      <Declaration><![CDATA[// returns mark lenght in [um] (with current resolution)
METHOD PRIVATE getMarkLength : LREAL
VAR_INPUT
  nStart : DINT;      // pulse / um
  nEnd : DINT;    // pulse / um
END_VAR
VAR
  nDist : DINT;  // [pulse]
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// pulse elapsed * resolution [pulse/um] => pos in [um]
nDist := ABS(nEnd - nStart);
getMarkLength := nDist * fCurrentResolution;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{ac39b667-8b90-4a38-b9db-5deaa270f17b}">
      <Declaration><![CDATA[METHOD Init
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bInitOk := TRUE;
Reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="measure" Id="{67cbae6f-8d48-4bd4-86d9-cdcb6b146f3f}">
      <Declaration><![CDATA[METHOD PRIVATE measure
VAR_OUTPUT
  bUpdate : BOOL;
  fEncoderDistance : LREAL;
END_VAR
VAR_INST
  bS1_MarkStarted, bS2_MarkStarted : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bUpdate := FALSE;
bRising_S1 := fbMark1.RT;
bRising_S2 := fbMark2.RT;
bFalling_S1 := fbMark1.FT;    // wait on falling edge always 
bFalling_S2 := fbMark2.FT;


IF NOT bMeasurementActive THEN
  
  //-- S1 sensor evaluation (no measurement is active)
  // rising
  IF bRising_S1 AND NOT bS1_MarkStarted THEN
    nPosStart := getExactPosition(tNow:=tNowDc, nPos:=nPulse, tEdge:=tIKp_TimeStampPos01, fSpeed:=fSpeed);
    bS1_MarkStarted := TRUE;
    bAborted := FALSE; bMarkInvalidLength_S1 := FALSE; bMarkInvalidLenght_S2 := FALSE;
  END_IF

  // falling (after rising)
  IF bFalling_S1 AND bS1_MarkStarted THEN
    bS1_MarkStarted := FALSE;           // mark done
    nPosFalling1 := getExactPosition(tNow:=tNowDc, nPos:=nPulse, tEdge:=tIKn_TimeStampNeg01, fSpeed:=fSpeed);
  
    IF checkMarkLength( nRef := nPosStart, nOther := nPosFalling1) THEN
      bMeasurementActive := TRUE;           // start measurement after rising&falling edge
    ELSE
      bMarkInvalidLength_S1 := TRUE;
    END_IF

  // abort mark if no falling given
  ELSIF bS1_MarkStarted AND getMarkLength(nStart:=nPosStart, nEnd:=nPulse) > fMaxMarkLength THEN  // abort if max mark length exeeded
    bAborted := TRUE;
    bS1_MarkStarted := FALSE;         // mark done
    bMarkInvalidLength_S1 := TRUE;    // mark end missed (too long?)
    IF bVerbose THEN LogWarning('S1 mark missing end, mark too long, ignore mark'); END_IF
  END_IF
  
ELSE
  
  //-- S2 Second Sensor (Stop) evaluation when measurement is active
  //   only when measurement started and rising within range
  IF (nPulse - nPosStart) >= fEncoderPulseDistMin THEN                  // bigger than minimum pulse (enable sensor 2 detection)
    // rising
    IF bRising_S2 AND NOT bS2_MarkStarted THEN 
      nPosEnd := getExactPosition(tNow:=tNowDc, nPos:=nPulse, tEdge:=tIKp_TimeStampPos02, fSpeed:=fSpeed);    
      bAborted := FALSE; bMarkInvalidLenght_S2 := FALSE;
      bS2_MarkStarted := TRUE;  
    END_IF
    
    // falling
    IF bFalling_S2 AND bS2_MarkStarted THEN
      bS2_MarkStarted := FALSE;
      nPosFalling2 := getExactPosition(tNow:=tNowDc, nPos:=nPulse, tEdge:=tIKn_TimeStampNeg02, fSpeed:=fSpeed);  
      
      IF checkMarkLength( nRef := nPosEnd, nOther := nPosFalling2) THEN
        bUpdate := TRUE;
        bMeasurementActive := FALSE;      // stop measurement
      ELSE
        bMarkInvalidLenght_S2 := TRUE;
      END_IF

    // abort mark if no falling given
    ELSIF bS2_MarkStarted AND getMarkLength(nStart:=nPosEnd, nEnd:=nPulse) > fMaxMarkLength THEN  // abort if max mark length exeeded
      bAborted := TRUE;
      bS1_MarkStarted := FALSE;         // mark done
      bMarkInvalidLength_S1 := TRUE;    // mark end missed (too long?)
    IF bVerbose THEN LogWarning('S2 mark missing end, mark too long, ignore mark'); END_IF
    END_IF
  
  // abort measurement, no valid mark within max pulse distance
  ELSIF ( (nPulse - nPosStart) > (fEncoderPulseDistMax) ) THEN    // bigger than maximum pulse (disable sensor 2 and abort measurement)
    IF bVerbose THEN LogWarning('S2 mark detected too far , ignore measurement'); END_IF
    bAborted := TRUE;                   // abort measurement
    bMeasurementActive := FALSE;        // abort measurement
    bS2_MarkStarted := FALSE;           // mark done
  
  // invalid speed (machine stopped while measuring) ignore any triggers
  ELSIF fSpeed = 0 THEN
    bS1_MarkStarted := bS2_MarkStarted := FALSE;
    bMeasurementActive := FALSE;
	END_IF
  
END_IF

// debug current distance (view)
IF bMeasurementActive THEN
  nCurrentDistActive := (nPulse - nPosStart);
END_IF

// valid measurment -> update output
IF bUpdate THEN
  fEncoderDistance := nPosEnd-nPosStart;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{d5fe1b7c-5060-4be1-aff0-fdec2471f305}">
      <Declaration><![CDATA[METHOD PRIVATE Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMeasurementCounter := 0;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection">
      <LineId Id="5616" Count="20" />
      <LineId Id="5678" Count="0" />
      <LineId Id="5687" Count="0" />
      <LineId Id="5647" Count="7" />
      <LineId Id="5661" Count="0" />
      <LineId Id="5664" Count="0" />
      <LineId Id="5666" Count="0" />
      <LineId Id="5669" Count="0" />
      <LineId Id="5665" Count="0" />
      <LineId Id="5670" Count="0" />
      <LineId Id="5655" Count="1" />
      <LineId Id="5667" Count="0" />
      <LineId Id="5657" Count="2" />
      <LineId Id="5164" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.calcCycleTime">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.checkMarkLength">
      <LineId Id="38" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.getExactPosition">
      <LineId Id="25" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="26" Count="10" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.getMarkLength">
      <LineId Id="16" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="49" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.Init">
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.measure">
      <LineId Id="192" Count="0" />
      <LineId Id="234" Count="1" />
      <LineId Id="193" Count="1" />
      <LineId Id="236" Count="0" />
      <LineId Id="196" Count="0" />
      <LineId Id="273" Count="0" />
      <LineId Id="358" Count="0" />
      <LineId Id="341" Count="1" />
      <LineId Id="296" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="346" Count="0" />
      <LineId Id="352" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="355" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="280" Count="0" />
      <LineId Id="350" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="353" Count="0" />
      <LineId Id="283" Count="1" />
      <LineId Id="288" Count="0" />
      <LineId Id="291" Count="1" />
      <LineId Id="354" Count="0" />
      <LineId Id="349" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="347" Count="0" />
      <LineId Id="351" Count="0" />
      <LineId Id="356" Count="0" />
      <LineId Id="382" Count="0" />
      <LineId Id="294" Count="0" />
      <LineId Id="339" Count="1" />
      <LineId Id="357" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="301" Count="0" />
      <LineId Id="313" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="361" Count="0" />
      <LineId Id="359" Count="0" />
      <LineId Id="311" Count="0" />
      <LineId Id="373" Count="0" />
      <LineId Id="314" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="317" Count="2" />
      <LineId Id="322" Count="0" />
      <LineId Id="372" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="326" Count="1" />
      <LineId Id="376" Count="5" />
      <LineId Id="383" Count="0" />
      <LineId Id="375" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="384" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="307" Count="1" />
      <LineId Id="306" Count="0" />
      <LineId Id="332" Count="0" />
      <LineId Id="385" Count="1" />
      <LineId Id="333" Count="0" />
      <LineId Id="387" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="304" Count="0" />
      <LineId Id="388" Count="0" />
      <LineId Id="302" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="329" Count="1" />
      <LineId Id="389" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="369" Count="0" />
      <LineId Id="366" Count="1" />
      <LineId Id="365" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_EffectiveEncoderResolutionDetection.Reset">
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
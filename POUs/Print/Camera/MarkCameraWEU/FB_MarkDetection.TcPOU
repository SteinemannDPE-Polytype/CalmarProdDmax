<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MarkDetection" Id="{2e40260b-0516-412a-ad68-9d25ea4c3ac6}" SpecialFunc="None">
    <Declaration><![CDATA[(*
  Detects Marks and generates StartTrigger based on one EL1252 timestamp input I/O.
  Implements a CameraTrigger instance as well.
  
  Additionally:
    - returns lateral offset (+/- in [m]) to center of detected marks.
    - manages & supervises mark sequence
    - is a CameraTrigger as well
    - supports simulation mode
  
  NOTE: 
    - a mark has always a rising and falling edge of the sensor (triangle)
    - center position is the middle of the triangular mark

*)
FUNCTION_BLOCK FB_MarkDetection EXTENDS T_NamedBase IMPLEMENTS I_StartPosDetect, I_CameraTrigger, I_Sim
VAR_INPUT
  (*EL1252*)
  bIKp_StartSensor          AT%I* : BOOL;             (*Sensor start trigger*)
  tIKp_TimeStampPos         AT%I* : T_DCTIME64;       (*TimeStamp Pos_Edge @EL1252*)
  tIKn_TimeStampNeg         AT%I* : T_DCTIME64;       (*TimeStamp Neg_Edge @EL1252*)

  // configuration
  bEnable                         : BOOL;             (*Enable start pos detection sensor (from extern)*)
  bAutomaticMode                  : BOOL;             (*machine is in automatic mode *)
  nCurrentPos                     : DINT;             (*current position in Pulses/Subpixels*)
  fCurrentSpeed                   : LREAL;            (*actual speed of conveyor in [m/s]*)
  bReverse                        : BOOL;             (*reverse printing same roll feeded in opposite direction, check falling edge in this case*)
  
  // Debug & Test
  bManualTrigger                  : BOOL;             // Manual start trigger
  bManualReset                    : BOOL;             // Manaul reset detection
END_VAR
VAR
  bInitOk                         : BOOL;             // fb initialized

  // config
  _fResolution                    : LREAL := 1;       // current used print resolution (dpi*SubPx)
  _pFbMarkDefinition              : POINTER TO FB_MarkDefinition;      // mark definition
  _iCamera                        : I_Camera;         // camera interface
  // settings                                    
  _bUseCameraTrigger              : BOOL;             // (cam specific setting) Generate camera trigger output
  _bUseCameraTriggerFeedback      : BOOL;             // (cam specific setting) Evaluate camera triggered feedback
  _bCamManualTeachMode            : BOOL;             // cam in manual teach mode
  _fSubstrateLength               : LREAL;            // Substrate length in [m] (should be repeat length)
  _fTriggerDistance               : LREAL;            // Distance between Sensor and Trigger [m]
  _fTriggerLength                 : LREAL := 10;      // Length of trigger signal in ms, min. 3 bus cycles
  _iActiveCam                     : I_CameraTriggerDevice;  // active camera interface (set by Enable() on I_CameraTrigger)

  bCamValid                       : BOOL;             (*camera is valid*)
  bMarksTeached                   : BOOL;             (*definition is valid marks&substrate*)
  bSpeedValid                     : BOOL;             (*speed is valid*)
  bTriggerArmed                   : BOOL;             (*trigger is armed*)
  bDetectionRunning               : BOOL;             (*detection running an initial start mark was found*)
  bSheetActive                    : BOOL;             (*sheet is scanning*)
    
  // helper
  rfT_Enable                      : RF_TRIG;          // edge detection
  bFound                          : BOOL;             // a mark found
  bTypeStartMark                  : BOOL;             // it is type of start mark
  isMarkMissing                   : BOOL;
  nMarkSelection                  : UDINT := 1;       // Current selected mask to search
  pMarkSearch                     : POINTER TO ST_MarkDefinition;
  _fSubstrateLengthEffective      : LREAL;            // Substrate length in [m]

  
  // time calculations
  tNowDc                          : T_DCTIME64;       // Get Current Timestamp (now)
  fCycleTime                      : LREAL;            // Current calculated cycle time [s]
  
  // I_StartPosDetect
  _bStartTrig                     : BOOL;             // Start Trigger Edge
  _nX0                            : DINT;             // X0 Position [SubPx]
  _bValid                         : BOOL;             // valid start trigger
  
  // errors
  nCtrSensorDetectError           : UDINT;            // error counter for senor detect invalid signals
  nCtrIgnoredMarks                : UDINT;            // error counter for ignored marks
  bNoStartMarkDetected            : BOOL;             // no start mark detected after x repeats
  bInvalidRepeatLength            : BOOL;             // invalid repeat length (StartMarks too close or too far away from each other)
  bInvalidMarkDetected            : BOOL;
  _bMarkDetectionErrors           : BOOL;             // invalid sensor signal
  _bMissingMarks                  : BOOL;             // some "valid"* marks were ignored
  
  // simulation & debug
  _bSimEnable                     : BOOL;             // simulation mode enabled
  _nSimMode                       : UDINT;            // simulation mode 0=Simulate Marks, 1=Simulate Sensor 
  _bVerbose                       : BOOL;             // verbose mode
  _fSubstrateGap                  : LREAL;            // Gap between two substrates (sheets/repeats) for simulation
  
  // local for checkForMark
  rfEdgeSensor                    : RF_TRIG;          // edge detection start trigger
  bResetDetection                 : BOOL;             // Reset request for checkForMark() internals

  fRealMarkLength                 : LREAL;
  nRealMarkPosition               : DINT;
  nPosRepeatSupervision           : DINT;             // position sample for supervision of missing StartMarks
  nLastGeneratedStartMarkPosition : DINT;
  bMarkStartDetected              : BOOL;             // mark started
  bMarkEndDetected                : BOOL;             // marks end reached
  bInhibitTrigger                 : BOOL;             // inhibit sensor signals, TRUE=inhibit
  
  // history 
  // - repeat
  sRepeatHistory : ARRAY[0..nC_HistorySize-1] OF ST_RepeatHistory;   // detection history
  nRepeatCt : UDINT;                 // history entry selector
  // - marks
  sMarkHistory : ARRAY[0..nC_HistorySize-1] OF ST_MarkDefinition;   // history of detected marks
  nMarkHistoryCt : UDINT;            // history entry selector
  // test
  bSim_Mark_Displacement : BOOL;
  fSim_Dx_Fix, fSim_Dy_Fix : LREAL;     // simulate some fix deviation of detected marks [m]
END_VAR
VAR PERSISTENT
  bR_TerminateLast                : BOOL;             // Terminate sheet with last defined & detected mark
  nR_SpeedMavFilterSamples        : UINT := 0;        // moving average filter samples = 0 deactivated
END_VAR
VAR CONSTANT
  fC_MinimalSpeed                 : LREAL := 0.010;   // [m/s] speed valid (used for trigger activation)

  fC_MaxSubstrateFactor           : LREAL := 1.1;     // factor which the sheet length can be max. longer
  fC_MinSubstrateFactor           : LREAL := 0.9;     // factor which the sheet length can be smaller
  nC_MaxRepeatsWithoutStart       : LREAL := 3;       // max repeats (theoretical distance) without a detected start trigger before error
  nC_AreaMarkSensorOk             : INT := 10;        // [%] Area with the correct arrangement of the mark sensor
  nC_HistorySize                  : UDINT := 20;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// check parameter
IF NOT bInitOk THEN RETURN; END_IF

// General calculations
bSpeedValid   := fCurrentSpeed > fC_MinimalSpeed;                // speed valid (ignore trigger if not moving)
bCamValid     := SEL(_iActiveCam<>0, FALSE, TRUE);               // camera valid (ignore trigger otherwise)
bMarksTeached    := (_fSubstrateLength > 0 AND _pFbMarkDefinition^.nMarks > 0);
tNowDc        := F_GetCurDcTaskTime64();                         // current dc time (most accurate time stamp we have)
fCycleTime    := calcCycleTime(tCurrent:=tNowDc);                // calculate cycle time of this fb
bTriggerArmed :=  bCamValid AND bSpeedValid AND bEnable AND bMarksTeached AND (bAutomaticMode OR _bCamManualTeachMode OR _bSimEnable);   // trigger

IF bCamValid THEN    // (not yet used) save dynamic changable settings
  _fTriggerDistance := _iActiveCam.fTriggerDistance;
  _fTriggerLength   := _iActiveCam.fTriggerPulseLength;
END_IF

_bValid := _bStartTrig := FALSE;    // default values (outputs and properties)

manualTrigger();     // handle manual trigger


// enable & reset
rfT_Enable(CLK:=bTriggerArmed);             // edge detection for detection started
IF rfT_Enable.RT OR rfT_Enable.FT OR bManualReset THEN Reset(); bManualReset:=FALSE; END_IF;
IF NOT bEnable THEN RETURN; END_IF    // do nothing if not enabled
IF NOT bTriggerArmed THEN RETURN; END_IF




(*Mark search ----------------------------------------------------------------*)
IF nMarkSelection > _pFbMarkDefinition^.nMarks OR nMarkSelection = 0 THEN nMarkSelection := 1; END_IF  // fix invalid selection
pMarkSearch :=  _pFbMarkDefinition^.getMark(nIdx:=TO_DINT(nMarkSelection));

// --- Simulation for testing
IF _bSimEnable AND _nSimMode = 0 THEN   // simulate some marks for testing
  bFound := SimMarks(pMark:=pMarkSearch, bStartMark=>bTypeStartMark);

// --- Generate masks if none are available
ELSIF pMarkSearch^.bVirtual THEN    // generate marks (for NoMark mode)
  bFound := GenMark(pMark:=pMarkSearch, bStartMark=>bTypeStartMark);

// --- Default by IO signal
ELSE
  bFound := searchForMark(   bSensorSignal := bIKp_StartSensor
                           , tSensorRisingEdge := tIKp_TimeStampPos
                           , tSensorFallingEdge := tIKn_TimeStampNeg
                           , nCurrentPos := nCurrentPos
                           , fSpeed := fCurrentSpeed
                           , fDuration := 
                           , fDetectedMarkLength => fRealMarkLength
                           , nDetectedMarkPosition => nRealMarkPosition
                           , bStartMark => bTypeStartMark
                         );
END_IF

(*Mark handling ----------------------------------------------------------------*)
IF bFound THEN
  
  // verify if correct mark type-> ignore else
  IF nMarkSelection = 1 AND NOT bTypeStartMark THEN  
    // err - search start mark but other valid found
    nCtrIgnoredMarks := nCtrIgnoredMarks + 1;   // ignored
    
  ELSIF nMarkSelection > 1 AND bTypeStartMark THEN   
    // err - search intermediate but found start mark
    nCtrIgnoredMarks := nCtrIgnoredMarks + 1;   // ignored
    
  ELSIF nMarkSelection = 1 AND bTypeStartMark THEN
    // ok - start mark   
    IF _pFbMarkDefinition^.nMarks = 1 THEN    // only one mark --> TERMINATE + START
      SheetStart(pMark:=pMarkSearch);        // start sheet/repeat
      IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF  // TERMINATE already after single mark scanned
    ELSE                                     // more marks --> START + NEXT
      SheetStart(pMark:=pMarkSearch);        // start sheet/repeat
      nMarkSelection := nMarkSelection + 1;  // next mark
    END_IF
    
  ELSIF nMarkSelection > 1 AND NOT bTypeStartMark THEN
    // ok - intermediate mark
    // search and found other --> NEXT (ev. terminate)
    IF _pFbMarkDefinition^.nMarksDetected < _pFbMarkDefinition^.nMarks THEN
      _pFbMarkDefinition^.saveMark(pMark:=pMarkSearch);           // save mark
      SaveToMarkHistory(pMark:=pMarkSearch);                      // Save to mark history
      IF nMarkSelection = _pFbMarkDefinition^.nMarks THEN         // last mark?
        IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF     // stop 
        nMarkSelection := 1;                                      // search start again
      ELSE
        nMarkSelection := SEL(nMarkSelection<_pFbMarkDefinition^.nMarks, 1, nMarkSelection + 1);  // search next
      END_IF
    END_IF
    
  ELSE
    // err = not covered check
    nCtrIgnoredMarks := nCtrIgnoredMarks + 1;
  END_IF 

ELSE
  // search if intermediate mark was missed -> create a virtual one
  IF pMarkSearch^.nId > 1 AND (nCurrentPos - getLastX0() - getMaxMarkPosition(pMark:=pMarkSearch)) > 0 THEN
    setupMark(
      pMark:=pMarkSearch,
      nDetectedPos:=getLastX0()+F_MeterToSubPixel(fPosMeter:=pMarkSearch^.fPosX, fResoSubPx:=_fResolution),
      fRealMarkLength:=pMarkSearch^.fSqLength+pMarkSearch^.fTrLength/2,
      bMissed:=TRUE
    );
    
    IF _pFbMarkDefinition^.nMarksDetected < _pFbMarkDefinition^.nMarks THEN
      _pFbMarkDefinition^.saveMark(pMark:=pMarkSearch);           // save mark
      SaveToMarkHistory(pMark:=pMarkSearch);                      // Save to mark history
      IF nMarkSelection = _pFbMarkDefinition^.nMarks THEN         // last mark?
        IF bR_TerminateLast THEN SheetStop(nNewX0:=0); END_IF     // stop 
        nMarkSelection := 1;                                      // search start again
      ELSE
        nMarkSelection := SEL(nMarkSelection<_pFbMarkDefinition^.nMarks, 1, nMarkSelection + 1);  // search next
      END_IF
    END_IF
    
  END_IF
END_IF


// --- Error Handling
_bMarkDetectionErrors := nCtrSensorDetectError > 0;
_bMissingMarks        := nCtrIgnoredMarks > 0;

// TODO:
//  - Check for missing Start mark -> bity
//  - Invalid sheet length detecte



// outputs
// _bStartTrig := // set in SheetStart
// _nX0 :=  // set in SheetStart
_bValid := TRUE;
]]></ST>
    </Implementation>
    <Folder Name="I_CameraTrigger" Id="{61025858-3f64-4567-bc63-cad039cb5a41}" />
    <Folder Name="I_Sim" Id="{fc40c9c0-6ffc-48f9-9a25-0caade00001b}" />
    <Folder Name="I_StartPosDetect" Id="{d37fb0ec-56d2-495c-adf6-ff9180f44f32}" />
    <Folder Name="Sim" Id="{b1696160-437d-44da-b8b0-e17e98d5f336}" />
    <Method Name="ackErrors" Id="{c760e099-bed4-4b63-998e-3ea29259e07c}">
      <Declaration><![CDATA[METHOD ackErrors
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nCtrSensorDetectError := 0;
nCtrIgnoredMarks := 0;
_bMarkDetectionErrors := FALSE;
_bMissingMarks := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Property Name="bManualTeach" Id="{0f146740-aee9-4ec7-925b-29443b51715f}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[PROPERTY bManualTeach : BOOL
]]></Declaration>
      <Get Name="Get" Id="{35dd5d39-cb95-435f-b386-89b4d163e9fb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bManualTeach := _bCamManualTeachMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{7795fe12-0fce-4a26-819c-aab3ec4e98db}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bCamManualTeachMode := bManualTeach;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bSimEnable" Id="{e1c627f8-8588-4379-b102-23cc2e5d15f3}" FolderPath="I_Sim\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
(*Simulation is enabled set/get*)
PROPERTY bSimEnable : BOOL
]]></Declaration>
      <Get Name="Get" Id="{34b5868b-6a07-4310-90f0-c10e9b8f8e93}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSimEnable := _bSimEnable;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1495d918-882a-4585-a0fd-ae06fe59cb67}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_bSimEnable := bSimEnable;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="bStartTrig" Id="{b5e6ebce-63c2-4d49-86d8-1c5d483112b1}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A new container detected.
  NOTE: a pulse only
*)
PROPERTY bStartTrig : BOOL
]]></Declaration>
      <Get Name="Get" Id="{b2bcb549-65a0-4869-9631-bc10a9ddceb4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bStartTrig := _bStartTrig;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="bValid" Id="{8684c458-d020-4db4-a3bd-6f3168f30def}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  A valid container detected.
*)
PROPERTY bValid : BOOL
]]></Declaration>
      <Get Name="Get" Id="{91bda4b7-57a6-4287-b500-d42f619ca9e0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bValid := _bValid;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="calcCycleTime" Id="{3fe2434d-c906-4dc0-b19b-45f340a130cf}">
      <Declaration><![CDATA[// cycle time in [s]
METHOD PRIVATE calcCycleTime : LREAL
VAR_INPUT
  tCurrent : T_DCTIME64;
END_VAR
VAR_INST
  tLastTimeStamp : T_DCTIME64 := 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[calcCycleTime := (TO_LREAL(tCurrent) - TO_LREAL(tLastTimeStamp)) * 1E-9;
tLastTimeStamp  := tCurrent;  // memory timestamp]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disable" Id="{11fdf59e-4145-49d1-a134-a7f58450fd1d}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Disable : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_iActiveCam := 0;
Disable := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{e3a0cf97-54c5-4265-8f1b-23bf66b4896c}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD Enable : BOOL
VAR_INPUT
	iCam	                    : I_CameraTriggerDevice;
  bUseCameraTrigger         : BOOL; //Generate camera trigger
  bUseCameraTriggerFeedback : BOOL; //Use feedback as trigger?
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iCam = 0 THEN
  Enable := FALSE;
  LogError('setCam failed: invalid reference');
ELSE
  _iActiveCam := iCam;
  Enable     := TRUE;

  // save constant settings
  _bUseCameraTrigger := bUseCameraTrigger;
  _bUseCameraTriggerFeedback := bUseCameraTriggerFeedback;
  
  IF _bUseCameraTrigger OR _bUseCameraTriggerFeedback THEN
    LogWarning('Enable: Camera Trigger output/feedback not yet supported');
	END_IF
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Property Name="fSubstrateGap" Id="{fa816ede-3849-4429-8dd8-f67f2bed0f5c}" FolderPath="Sim\">
      <Declaration><![CDATA[PROPERTY fSubstrateGap : LREAL]]></Declaration>
      <Set Name="Set" Id="{11757de8-9549-4089-9527-c78d4f65c2a0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_fSubstrateGap := fSubstrateGap;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="GenMark" Id="{71ebed74-368f-4d73-b772-efc61bd12a13}">
      <Declaration><![CDATA[(*
  Generate detected marks.
*)
METHOD PRIVATE GenMark : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  n : DINT;
  nImageLength : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

nImageLength := F_MeterToSubPixel(fPosMeter:=_fSubstrateLength + _fSubstrateGap, fResoSubPx:=_fResolution);
IF nImageLength = 0 THEN RETURN; END_IF


IF NOT bMarkOn THEN  // start new mark

  // create rising edge
  IF pMark^.nId = 1 THEN          // a start mark
    // wait for next StartPosition
    IF nCurrentPos >= nLastGeneratedStartMarkPosition + nImageLength THEN

      // fix bigger gaps than next sheet (always try to start repeats at a multiple of last repeat)
      IF (nCurrentPos - nLastGeneratedStartMarkPosition) / nImageLength > 2 THEN
        nLastGeneratedStartMarkPosition := nLastGeneratedStartMarkPosition + ((((nCurrentPos - nLastGeneratedStartMarkPosition) / nImageLength) -1) * nImageLength);  // correct to one sheet before 
			END_IF 
      
      nLastGeneratedStartMarkPosition := nLastGeneratedStartMarkPosition + nImageLength;      // save last repeat position   
      
      pMark^.sState.nPosXReal := nLastGeneratedStartMarkPosition + F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution); // mark detected position
      pMark^.sState.fLengthReal := 0;
      pMark^.sState.dx := 0;
      pMark^.sState.dy := 0;
      pMark^.sState.bInArea := TRUE;
      pMark^.sState.bSet := TRUE;
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= pMark^.fPosX THEN
     
      pMark^.sState.nPosXReal := nLastGeneratedStartMarkPosition + F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution); // 
      pMark^.sState.fLengthReal := 0;
      pMark^.sState.dx := 0;
      pMark^.sState.dy := 0;
      pMark^.sState.bInArea := TRUE;
      pMark^.sState.bSet := TRUE;
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // end mark after one dycle
  bMarkOn := FALSE;
  IF pMark^.nId = 1 THEN bStartMark := TRUE; END_IF  
  GenMark := TRUE;      // reset after one cycle active
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getExactPosition" Id="{787e1362-d4e9-419e-b832-57f89325f090}">
      <Declaration><![CDATA[// calculate the exact detected position
// :returns: the X0 position
METHOD PRIVATE getExactPosition : DINT
VAR_INPUT
  tNow              : T_DCTIME64;    // current system time
  tEdge             : T_DCTIME64;   // detected time
  nPos              : DINT;          // current (encoder) position at the current time
  fSpeed            : LREAL;       // current speed for the timestamped position correction calculation
END_VAR
VAR
  fCurrentTimeStamp : LREAL;
  fSensor_TimeStamp : LREAL;
  nDeltaPosition    : DINT;       // distance [SubPx]
  fDeltaDistance    : LREAL;      // Distance that the substrate moved between the detection and the treatment of the information
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _bSimEnable THEN // calculation like DMAX for simulation mode
  fDeltaDistance := UINT64_TO_LREAL(UInt64Sub64(ULINT_TO_ULARGE(tNowDc), ULINT_TO_ULARGE(tEdge))) * 1E-9 * fSpeed;
  getExactPosition := nPos - F_MeterToSubPixel(fPosMeter:=fDeltaDistance, fResoSubPx:=_fResolution);
  RETURN; 
END_IF

// Calculate the original position back from timestamp input trigger (compensated)
fCurrentTimeStamp  := (ULINT_TO_LREAL(tNow) - (GVL_WEU.nC_CurrentTimeStampComp * 1_000)) / 1_000_000.0; // [ms]
fSensor_TimeStamp := (ULINT_TO_LREAL(tEdge) - (GVL_WEU.nC_SensorTimeStampComp  * 1_000)) / 1_000_000.0; // [ms]

// Treatment of the information
fDeltaDistance   := (fCurrentTimeStamp - fSensor_TimeStamp) * 0.001 * fSpeed;	      // Distance in pulses that the substrate has traveled between the sensor detection and the PLC treatment
nDeltaPosition := FC_LREAL_TO_DINT(fDeltaDistance * (1 / (0.0254 / _fResolution)));   // 1/1px*)	(* Travel of the substrate between the time of acquisition and the time of treatment
getExactPosition := nPos - nDeltaPosition;	                                          // Position where the sheet has been detected
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getLastX0" Id="{84e34a73-b689-41b3-a4ab-908cac33c796}">
      <Declaration><![CDATA[(*
  Get X0 from detected start mark
*)
METHOD PRIVATE getLastX0 : DINT
VAR
  pLastStartMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pLastStartMark := _pFbMarkDefinition^.pLastStartMark;
IF pLastStartMark <> 0 THEN
  getLastX0 := pLastStartMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pLastStartMark^.fPosX, fResoSubPx:=_fResolution);
END_IF
 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="getMarkDistanceEffective" Id="{8aa0921c-f32f-4594-b0cd-a09cae6dbec6}">
      <Declaration><![CDATA[(*
  Calculate effective distance of mark to X0 [m]
*)
METHOD PRIVATE getMarkDistanceEffective : LREAL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  pFirstMark : POINTER TO ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

IF pMark^.nId = 1 THEN 
  getMarkDistanceEffective := pMark^.fPosX;
ELSE
  pFirstMark := _pFbMarkDefinition^.getMark(nIdx:=1);
  IF pFirstMark <> 0 THEN
    // real distance between this mark and start mark + fPosX of start mark
    getMarkDistanceEffective := pFirstMark^.fPosX + F_SubPixelToMeter(lPosSubPx:=pMark^.sState.nPosXReal - pFirstMark^.sState.nPosXReal, fResSubPx:=_fResolution);
  END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getMaxMarkPosition" Id="{0fbd1c3f-df1c-4057-a85c-91aa71449d46}">
      <Declaration><![CDATA[// get max. mark distance from the sheetStart (teached + margin) [SubPx]
METHOD getMaxMarkPosition : DINT
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

getMaxMarkPosition := F_MeterToSubPixel(fPosMeter:=pMark^.fPosX + pMark^.fSqLength + pMark^.fTrLength + _pFbMarkDefinition^.fMarkLengthMargin, fResoSubPx:=_fResolution);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{bf7daa9f-61d2-488a-b10c-adc956e254bf}">
      <Declaration><![CDATA[METHOD Init
VAR_INPUT
  fPrintResolution      : LREAL := 600;         // print(head) resolution in [dpi]
  fSubPxResolution      : LREAL := 32;          // SubPixel resolution [SubPx], resolution factor (fI_PrintResolution*fI_SubPxResolution=>Output resolution)
  pFbMarkDefinition     : POINTER TO FB_MarkDefinition;
END_VAR
VAR
  i : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fPrintResolution = 0 OR fSubPxResolution = 0 OR pFbMarkDefinition = 0 THEN LogError('Init: invalid parameter'); RETURN; END_IF

_fResolution := fPrintResolution * fSubPxResolution;
_pFbMarkDefinition:= pFbMarkDefinition;

Reset();

bInitOk := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="manualTrigger" Id="{e82df52a-8d4c-4d05-9deb-e05001d061c5}" FolderPath="Sim\">
      <Declaration><![CDATA[METHOD PRIVATE manualTrigger : BOOL
VAR_INST
  rfTrig_ManuTrigger : RF_TRIG;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rfTrig_ManuTrigger(CLK:=bManualTrigger);

IF rfTrig_ManuTrigger.RT THEN
  LogWarning('manualTrigger not yet implemented');
END_IF

manualTrigger := rfTrig_ManuTrigger.RT;]]></ST>
      </Implementation>
    </Method>
    <Property Name="nStartPositionX0" Id="{5838a0f3-97d0-42ec-b5ab-5f3957036f26}" FolderPath="I_StartPosDetect\">
      <Declaration><![CDATA[(*
  Detected start position X0 (absolute) in [SubPx].
*)
PROPERTY nStartPositionX0 : DINT
]]></Declaration>
      <Get Name="Get" Id="{f16ea759-3077-4803-9f55-29a6efd6c652}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nStartPositionX0 := _nX0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Reset" Id="{a9f4bd9a-7d4f-4ca9-bdbe-827086a3344c}">
      <Declaration><![CDATA[(*
  Reset internal state and all marks
*)
METHOD Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN; END_IF

_bValid := FALSE;
_bStartTrig := FALSE;
nMarkSelection := 1; // start mark
bDetectionRunning := FALSE;
nPosRepeatSupervision := nCurrentPos;       // sample activated detection position

// reset camera (release if one is selected)
IF bSheetActive THEN
  IF _iActiveCam <> 0 THEN _iActiveCam.CamTriggerDone(); END_IF   // notify an done/abort
END_IF
_pFbMarkDefinition^.ResetMarkStates();  // reset detected marks
bSheetActive := FALSE;
bResetDetection := TRUE;        // reset checkForMark() state machine

// reset errors
nCtrSensorDetectError := 0;
nCtrIgnoredMarks := 0;
bNoStartMarkDetected := FALSE;
bInvalidRepeatLength := FALSE;
bInvalidMarkDetected := FALSE;
_bMarkDetectionErrors := FALSE;
_bMissingMarks := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SaveToMarkHistory" Id="{a0d33772-1436-4a13-9664-ecc55fc2df79}">
      <Declaration><![CDATA[METHOD PRIVATE SaveToMarkHistory
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  i : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO nC_HistorySize-1 DO sMarkHistory[i].sView.colorFill := 16#FFE2DDDB; END_FOR   // clear selection
nMarkHistoryCt := (nMarkHistoryCt + 1) MOD nC_HistorySize;
sMarkHistory[nMarkHistoryCt] := pMark^;
sMarkHistory[nMarkHistoryCt].sView.colorFill := 16#FF90EE90;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="searchForMark" Id="{9369f661-23d9-48b5-ac1f-53061e7f498c}">
      <Declaration><![CDATA[(*
  Poll sensor signal for triggers and create mark info.
  :return: true if a mark was detected
*)
METHOD PRIVATE searchForMark : BOOL
VAR_INPUT
  bSensorSignal : BOOL;
  tSensorRisingEdge : T_DCTIME64;  // [us]
  tSensorFallingEdge : T_DCTIME64; // [us]
  nCurrentPos : DINT;              // [SubPx]
  fSpeed : LREAL;                  // [m/s]
END_VAR
VAR_OUTPUT
  fDuration : LREAL;
  fDetectedMarkLength : LREAL;  // [m]
  nDetectedMarkPosition : DINT; // [SubPx]
  bStartMark : BOOL;            // is it a start mark?
END_VAR
VAR_INST
  nAbortMarkAfterDist         : DINT;             // max. length to search for mark end before aborting this mark [SubPx]
  tRisingEdge, tFallingEdge   : T_DCTIME64;       // detected edges
  nRisingPos, nFallingPos     : DINT;             // detected [SubPx] pos
  fLengthByTime : LREAL;
  fLengthByPos  : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// reset methods internal states
IF bResetDetection THEN bResetDetection := FALSE;
  bMarkStartDetected := FALSE; bMarkEndDetected := FALSE;
  bInhibitTrigger := FALSE; 
END_IF

// simulate sensor
IF _bSimEnable AND _nSimMode = 1 THEN
  SimSensor(bSensorSimulationSignal=>bSensorSignal, tSensorRising=>tSensorRisingEdge, tSensorFalling=>tSensorFallingEdge);
END_IF

// -- TODO: inhibit control if needed


// --- Use sensor
rfEdgeSensor(CLK:=bSensorSignal);   // edge detection
nAbortMarkAfterDist := F_MeterToSubPixel(fPosMeter:=_pFbMarkDefinition^.fMaxMarkLength + _pFbMarkDefinition^.fMarkLengthMargin + fCycleTime*fCurrentSpeed, fResoSubPx:=_fResolution); // mark len + margin + one cycle


// -- rising edge detection
IF rfEdgeSensor.RT AND NOT bInhibitTrigger THEN
  tRisingEdge := tSensorRisingEdge;   // sample input
  nRisingPos  := getExactPosition(tNow:=tNowDc, tEdge:=tRisingEdge, nPos:=nCurrentPos, fSpeed:=fCurrentSpeed);   // position where mark was seen
  bMarkStartDetected := TRUE;
END_IF;

// -- falling edge detection
IF rfEdgeSensor.FT AND NOT bInhibitTrigger THEN
  // falling edge
  tFallingEdge := tSensorFallingEdge;
  nFallingPos := getExactPosition(tNow:=tNowDc, tEdge:=tFallingEdge, nPos:=nCurrentPos, fSpeed:=fCurrentSpeed);   // position where mark was seen
  IF NOT bMarkStartDetected THEN
    // ignore
    nCtrSensorDetectError := nCtrSensorDetectError + 1;
    LogLvl(Lvl:=E_LogSeverity.Debug, Msg:='Missing rising trigger edge before falling edge');
    bResetDetection := TRUE;
  ELSE
    // ok                    
    bMarkEndDetected := TRUE; 
  END_IF
END_IF

// - error handling - abort search for falling edge
IF bMarkStartDetected AND (nCurrentPos - nRisingPos) > nAbortMarkAfterDist THEN      // abort after waiting for end
  // Abort - Expected falling edge missed
  nCtrSensorDetectError := nCtrSensorDetectError + 1;
  LogLvl(Lvl:=E_LogSeverity.Debug, Msg:=F_Concat2('Mark end not given after [SubPx]:', TO_STRING(nAbortMarkAfterDist)));
  bResetDetection := TRUE;   // reset detection logic
END_IF;


// -- mark evaluation 
IF bMarkStartDetected AND bMarkEndDetected THEN
  // mark found
  fDuration := ABS(ULINT_TO_LREAL(tFallingEdge) - ULINT_TO_LREAL(tRisingEdge));		// Calculate how long the signal was ON
  fLengthByTime := fDuration * fCurrentSpeed * 0.000_000_001;
  fLengthByPos := F_SubPixelToMeter(lPosSubPx:=nFallingPos - nRisingPos, fResSubPx:=_fResolution);
  fDetectedMarkLength := fLengthByPos;
  nDetectedMarkPosition := nRisingPos; // SEL(bReverse, nRisingPos, nFallingPos);
  
  // check if valid
  // - check if mark length is within defined range
  IF fDetectedMarkLength >= (_pFbMarkDefinition^.fMinMarkLength - _pFbMarkDefinition^.fMarkLengthMargin) AND 
     fDetectedMarkLength <= (_pFbMarkDefinition^.fMaxMarkLength + _pFbMarkDefinition^.fMarkLengthMargin) 
  THEN
    // valid
    // - is a startMark type?
    bStartMark := _pFbMarkDefinition^.isStartMark(fMarkLength:=fDetectedMarkLength);
    
    // setup & apply all data to mark structure
    setupMark(
      pMark:=pMarkSearch,
      nDetectedPos:=nDetectedMarkPosition,
      fRealMarkLength:=fDetectedMarkLength,
      bMissed:=FALSE
    );
          
    IF _bVerbose THEN LogInfo(F_Concat4('found ', SEL(bTypeStartMark,'Intermediate','StartMark'), ' ', strMark(pMark:=pMarkSearch))); END_IF
        
    searchForMark := TRUE;              // a valid mark detected
  ELSE 
    // error
    nCtrIgnoredMarks := nCtrIgnoredMarks + 1;
    LogLvl(lvl:=E_LogSeverity.Debug, Msg:='Invalid mark lenght found while searching - ignored');
	END_IF
  
  bResetDetection := TRUE;   // reset detection logic
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetSubstrateLength" Id="{7e1a6101-02d0-4c3e-aa36-2ea97ecee34e}" FolderPath="I_CameraTrigger\">
      <Declaration><![CDATA[METHOD SetSubstrateLength
VAR_INPUT
  fSubstrateLength : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bInitOk THEN RETURN;END_IF;

(*reduced by margin (for endless mode with potential smaller printed repetition)*)
_fSubstrateLength := fSubstrateLength;
//_nSubstrateLength := F_MeterToSubPixel(fPosMeter:=_fSubstrateLength, fResoSubPx:=_fResolution);]]></ST>
      </Implementation>
    </Method>
    <Method Name="setupMark" Id="{14fe248f-e037-45a6-bbe7-87d9d8a20d1b}">
      <Declaration><![CDATA[(*
  Setup a detected mark with its details and calculation.
  :returns:  TRUE if valid mark
*)
METHOD PRIVATE setupMark : BOOL
VAR_INPUT
  pMark           : POINTER TO ST_MarkDefinition;     // mark to search for
  nDetectedPos    : DINT;                             // detected position [SubPx]
  fRealMarkLength : LREAL;                            // real detected mark length [m]
  bMissed         : BOOL;                             // missing mark (but generated)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

// apply mark status information
pMark^.sState.bSet := TRUE;
pMark^.sState.bMissed := bMissed;
pMark^.sState.nPosXReal := nDetectedPos;          // save detected mark pos (rising in normal, falling in reverse print)
pMark^.sState.fLengthReal := fRealMarkLength;     // apply detected mark length

// - dx  (based on sheet begin) dx = current mark position - teached mark position ()
pMark^.sState.dx := getMarkDistanceEffective(pMark:=pMark) - pMark^.fPosX;
// - dy  lateral displacement. fHeight/2 (middle) is assumed to be the normal position, the displacement is calculated to this center
pMark^.sState.dy := ((pMark^.sState.fLengthReal - pMark^.fSqLength)/pMark^.fTrLength)*pMark^.fHeight-(pMark^.fHeight/2);

// use (overwrite) with some simulation values
IF bSim_Mark_Displacement THEN pMark^.sState.dx := fSim_Dx_Fix; pMark^.sState.dy := fSim_Dy_Fix; END_IF

// if marks are inverted (flipped along x-axis), the correction is inverted
IF pMark^.bInvertedX THEN  pMark^.sState.dy := -1*pMark^.sState.dy; END_IF

// check position qualitiy
pMark^.sState.bInArea := FC_COMPARE_RANGE_PERCENT( 
                                       fI_ValueSet := (pMark^.fHeight / 2)
                                     , fI_ValueActual  := (pMark^.fHeight / 2) + pMark^.sState.dy
                                     , fI_RangePercent := nC_AreaMarkSensorOk);

                                     
setupMark := pMark^.sState.bSet;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStart" Id="{11a85c1a-bb4e-4454-999c-8aa56c83d8cb}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStart
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR
  sMarkBackup : ST_MarkDefinition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_nX0 := pMark^.sState.nPosXReal - F_MeterToSubPixel(fPosMeter:=pMark^.fPosX, fResoSubPx:=_fResolution);
_bStartTrig := TRUE;
bDetectionRunning := TRUE;
bNoStartMarkDetected := FALSE;
bInvalidRepeatLength := FALSE;

// (force) terminate a sheet/repeat
IF bSheetActive THEN 
  IF _bVerbose THEN LogInfo(F_Concat2('Terminate sheet/repeat with new Start Mark', '')); END_IF
  sMarkBackup := pMark^;   // push 
  SheetStop(nNewX0:=_nX0);
  pMark^:= sMarkBackup;    // pop
END_IF

IF _bVerbose THEN LogInfo(F_Concat2('SheetStart at X0=', TO_STRING(_nX0))); END_IF

// save (start) mark
_pFbMarkDefinition^.saveMark(pMark:=pMark);
SaveToMarkHistory(pMark:=pMarkSearch);    // Save to mark history

// trigger camera
IF _iActiveCam<>0 THEN _iActiveCam.CamTrigger(bOk:=TRUE, nPos:=_nX0, nPosDeviation:=0, nX0:=_nX0); END_IF

// save for supervision
nPosRepeatSupervision := _nX0;

bSheetActive := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SheetStop" Id="{d476c41c-7386-4983-b620-4be97c03b70c}">
      <Declaration><![CDATA[METHOD PRIVATE SheetStop
VAR_INPUT
  nNewX0 : DINT;   // new detected X0
END_VAR
VAR_INST
  fSubstrateRealDiff : LREAL;   // [m]
  nSubstrareRealDiff : DINT;    // [SubPx]
END_VAR
VAR
  i : UDINT;
  pLastMark : POINTER TO ST_MarkDefinition;
  fD : LREAL;
  fSLen : LREAL;
  nDetectedX0 : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// - terminate
IF _bVerbose THEN LogInfo(F_Concat2('SheetStop()', '')); END_IF

fSLen := _fSubstrateLength;  // (default) original length

// calculate effective sheet length
nDetectedX0 := getLastX0();   // get sampled X0
IF nNewX0 <> 0 AND nDetectedX0 <> 0 THEN
  // real diff between two starts
  fD := F_SubPixelToMeter(lPosSubPx:=nNewX0 - nDetectedX0, fResSubPx:=_fResolution);
  IF fD < (_fSubstrateLength * fC_MaxSubstrateFactor) THEN
    fSLen := fD;
  END_IF 
ELSIF nNewX0 = 0 AND _pFbMarkDefinition^.nMarksDetected > 1 THEN
  // calculate based on last detected mark (a strech factor)
  pLastMark:= _pFbMarkDefinition^.getMark(nIdx:=0);     // get last available mark
  fD := getMarkDistanceEffective(pMark:=pLastMark); 
  fSLen := (pLastMark^.fPosX/SEL(fD<>0, pLastMark^.fPosX, fD)) * _fSubstrateLength; // estimate real length with last mark
END_IF
_fSubstrateLengthEffective := fSLen;
fSubstrateRealDiff := _fSubstrateLengthEffective - _fSubstrateLength;
nSubstrareRealDiff := (nNewX0 - nDetectedX0) - F_MeterToSubPixel(fPosMeter:=_fSubstrateLength, fResoSubPx:=_fResolution);

// debug history
FOR i:=0 TO nC_HistorySize-1 DO sRepeatHistory[i].bSelected := FALSE; END_FOR   // clear selection
nRepeatCt := (nRepeatCt + 1) MOD nC_HistorySize;
sRepeatHistory[nRepeatCt].bSelected       := TRUE;
sRepeatHistory[nRepeatCt].nIndex          := nRepeatCt+1;
sRepeatHistory[nRepeatCt].nX0             := nDetectedX0;
sRepeatHistory[nRepeatCt].fLen            := _fSubstrateLength * 1000;
sRepeatHistory[nRepeatCt].fLenEffective   := _fSubstrateLengthEffective * 1000;
sRepeatHistory[nRepeatCt].fLenDiff        := (fSubstrateRealDiff) * 1000;
sRepeatHistory[nRepeatCt].bLenNotInRange  := bInvalidRepeatLength;
sRepeatHistory[nRepeatCt].bInvalidIngoredMarks := _bMissingMarks;
sRepeatHistory[nRepeatCt].bMissingMarks   := _bMissingMarks;


IF _iActiveCam<>0 THEN _iActiveCam.CamTriggerDone(); END_IF 
_pFbMarkDefinition^.ResetMarkStates();

bSheetActive := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimMarks" Id="{356d8dfe-8146-420e-a949-71e2824a4052}" FolderPath="Sim\">
      <Declaration><![CDATA[METHOD PRIVATE SimMarks : BOOL
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_OUTPUT
  bStartMark : BOOL;
END_VAR
VAR_INST
  bMarkOn : BOOL;
  nMarkStarted : DINT;
  fStartMarkOffset : LREAL;
  rand : DRAND;
  rlrand : LREAL;
  l : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pMark = 0 THEN RETURN; END_IF

// when sim enabled AND auto-trigger then create a StartMark after every sheet/repeat length
//  then generate every following intermediate mark with a given length

IF NOT bMarkOn THEN  // start new mark
  // create rising edge
  IF pMark^.nId = 1 THEN
    // wait for next StartPosition
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= _fSubstrateLength + _fSubstrateGap THEN
      nLastGeneratedStartMarkPosition := nCurrentPos;      // save start mark pos
      fStartMarkOffset := pMark^.fPosX;   // save start mark displacement from X0
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixelReal(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
    END_IF
	ELSE
    // wait for next mark position
    IF F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution) >= pMark^.fPosX - fStartMarkOffset THEN
      pMark^.sState.nPosXReal := nCurrentPos;  // save rising edge
      nMarkStarted := nCurrentPos;
      l := F_MeterToSubPixelReal(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
      bMarkOn := TRUE;
		END_IF
  END_IF
  
ELSE
  // create falling edge
  IF (nCurrentPos - nMarkStarted) > l THEN
    rand(Seed:=13, Num=>rlrand);  // TODO: find a right scale 
    setupMark(
      pMark:=pMark,
      nDetectedPos:=nMarkStarted,
      fRealMarkLength:=F_SubPixelToMeter(lPosSubPx:=nCurrentPos - nMarkStarted, fResSubPx:=_fResolution),
      bMissed:=FALSE
    );
    bMarkOn := FALSE;
    If pMark^.nId = 1 THEN bStartMark := TRUE; END_IF
    SimMarks := TRUE;    // mark done
  END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimSensor" Id="{c088d903-e9cc-4a31-b916-486937d44d8c}" FolderPath="Sim\">
      <Declaration><![CDATA[// simulate marks with sensor simulation
METHOD PRIVATE SimSensor
VAR_INPUT
END_VAR
VAR_OUTPUT
  bSensorSimulationSignal : BOOL;
  tSensorRising           : T_DCTIME64;
  tSensorFalling          : T_DCTIME64;
END_VAR
VAR
  fDistToLastStart : LREAL;
END_VAR
VAR_INST
  nNextMarkId : DINT;     // internal selection of marks
  bMarkOn : BOOL;         // sensor is on
  pMark : POINTER TO ST_MarkDefinition;  
  nPosMarkStarted : DINT;
  fStartMarkOffset : LREAL;
  SimMarkLength : LREAL;
  tRising, tFalling : T_DCTIME64;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _pFbMarkDefinition = 0 THEN RETURN; END_IF
IF nNextMarkId = 0 THEN nNextMarkId := 1; END_IF   // start with 1 always

IF NOT bMarkOn THEN  // start new mark

  pMark := _pFbMarkDefinition^.getMark(nIdx:=nNextMarkId);  // get theoretical mark configuration
  IF pMark <> 0 THEN
    // create rising edge
    IF pMark^.nId = 1 THEN
      // wait for next StartPosition
      fDistToLastStart := F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution); 
      IF fDistToLastStart >= _fSubstrateLength + _fSubstrateGap THEN
        
        nPosMarkStarted := nCurrentPos;
        SimMarkLength := F_MeterToSubPixelReal(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length default
        
        nLastGeneratedStartMarkPosition := nCurrentPos;      // save start mark pos
        fStartMarkOffset := pMark^.fPosX;                    // save start mark displacement from X0
        tRising := tNowDc;
        bMarkOn := TRUE;
      END_IF
    ELSE
      // wait for next intermediate mark position
      fDistToLastStart := F_SubPixelToMeter(lPosSubPx:=ABS(nCurrentPos - nLastGeneratedStartMarkPosition), fResSubPx:=_fResolution);
      IF fDistToLastStart >= pMark^.fPosX - fStartMarkOffset THEN
        
        nPosMarkStarted := nCurrentPos;
        SimMarkLength := F_MeterToSubPixelReal(fPosMeter:=pMark^.fSqLength + (pMark^.fTrLength/2), fResoSubPx:=_fResolution); // mark length
        tRising := tNowDc;
        bMarkOn := TRUE;
      END_IF
    END_IF

  END_IF  
ELSE
  // create falling edge
  IF (nCurrentPos - nPosMarkStarted) >= SimMarkLength THEN
    tFalling := tNowDc;
    bMarkOn := FALSE;
    nNextMarkId := SEL(nNextMarkId = TO_DINT(_pFbMarkDefinition^.nMarks), nNextMarkId+1, 1);
  END_IF
END_IF

bSensorSimulationSignal := bMarkOn;
tSensorRising := tRising;
tSensorFalling := tFalling;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="strMark" Id="{545c3bba-29a7-44b7-98a8-902f78b71101}">
      <Declaration><![CDATA[METHOD strMark : T_MaxString
VAR_INPUT
  pMark : POINTER TO ST_MarkDefinition;
END_VAR
VAR_INST
  fbStrFormat : FB_FormatString;
END_VAR
VAR
  IdFormatted : STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbStrFormat(sFormat:='%.2d', arg1:=F_DINT(pMark^.nId), sOut=>IdFormatted);
strMark := F_Concat6(
  F_Concat2('Id:',   IdFormatted),
  F_Concat2(' Set:', SEL(pMark^.sState.bSet,'0','1')),
  F_Concat2(' posX:', LREAL_TO_FMTSTR( pMark^.fPosX, 5, TRUE )),
  F_Concat2(' posY:', LREAL_TO_FMTSTR( pMark^.fPosY, 5, TRUE )),
  F_Concat2(' dx:', LREAL_TO_FMTSTR( pMark^.sState.dx, 5, TRUE )),
  F_Concat2(' dy:', LREAL_TO_FMTSTR( pMark^.sState.dy, 5, TRUE )),
);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MarkDetection">
      <LineId Id="14542" Count="135" />
      <LineId Id="6884" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.ackErrors">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bManualTeach.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bManualTeach.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bSimEnable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bSimEnable.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bStartTrig.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.bValid.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.calcCycleTime">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Disable">
      <LineId Id="4" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Enable">
      <LineId Id="31" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="70" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.fSubstrateGap.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.GenMark">
      <LineId Id="441" Count="47" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getExactPosition">
      <LineId Id="156" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="138" Count="7" />
      <LineId Id="39" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getLastX0">
      <LineId Id="16" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getMarkDistanceEffective">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.getMaxMarkPosition">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Init">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.manualTrigger">
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.nStartPositionX0.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.Reset">
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="25" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="62" Count="1" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SaveToMarkHistory">
      <LineId Id="7" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.searchForMark">
      <LineId Id="832" Count="0" />
      <LineId Id="627" Count="2" />
      <LineId Id="631" Count="0" />
      <LineId Id="785" Count="0" />
      <LineId Id="784" Count="0" />
      <LineId Id="786" Count="2" />
      <LineId Id="835" Count="0" />
      <LineId Id="643" Count="0" />
      <LineId Id="836" Count="0" />
      <LineId Id="769" Count="0" />
      <LineId Id="645" Count="2" />
      <LineId Id="721" Count="0" />
      <LineId Id="708" Count="0" />
      <LineId Id="649" Count="5" />
      <LineId Id="833" Count="0" />
      <LineId Id="655" Count="8" />
      <LineId Id="715" Count="0" />
      <LineId Id="664" Count="4" />
      <LineId Id="834" Count="0" />
      <LineId Id="669" Count="5" />
      <LineId Id="676" Count="0" />
      <LineId Id="837" Count="0" />
      <LineId Id="677" Count="4" />
      <LineId Id="838" Count="0" />
      <LineId Id="847" Count="0" />
      <LineId Id="840" Count="0" />
      <LineId Id="851" Count="0" />
      <LineId Id="839" Count="0" />
      <LineId Id="883" Count="0" />
      <LineId Id="911" Count="0" />
      <LineId Id="852" Count="0" />
      <LineId Id="912" Count="1" />
      <LineId Id="885" Count="0" />
      <LineId Id="914" Count="1" />
      <LineId Id="925" Count="0" />
      <LineId Id="919" Count="5" />
      <LineId Id="916" Count="0" />
      <LineId Id="926" Count="1" />
      <LineId Id="918" Count="0" />
      <LineId Id="854" Count="0" />
      <LineId Id="856" Count="0" />
      <LineId Id="884" Count="0" />
      <LineId Id="857" Count="1" />
      <LineId Id="855" Count="0" />
      <LineId Id="702" Count="2" />
      <LineId Id="810" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SetSubstrateLength">
      <LineId Id="8" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.setupMark">
      <LineId Id="173" Count="0" />
      <LineId Id="401" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="402" Count="0" />
      <LineId Id="398" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="400" Count="0" />
      <LineId Id="408" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="405" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="397" Count="0" />
      <LineId Id="393" Count="1" />
      <LineId Id="391" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="194" Count="5" />
      <LineId Id="406" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="407" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SheetStart">
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="79" Count="2" />
      <LineId Id="45" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="48" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SheetStop">
      <LineId Id="54" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="59" Count="2" />
      <LineId Id="73" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="63" Count="5" />
      <LineId Id="110" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="149" Count="2" />
      <LineId Id="164" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="69" Count="3" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SimMarks">
      <LineId Id="178" Count="39" />
      <LineId Id="219" Count="1" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.SimSensor">
      <LineId Id="148" Count="9" />
      <LineId Id="213" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="220" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="221" Count="0" />
      <LineId Id="159" Count="1" />
      <LineId Id="226" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="165" Count="2" />
      <LineId Id="227" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="223" Count="0" />
      <LineId Id="169" Count="1" />
      <LineId Id="222" Count="0" />
      <LineId Id="225" Count="0" />
      <LineId Id="173" Count="1" />
      <LineId Id="215" Count="0" />
      <LineId Id="176" Count="3" />
      <LineId Id="181" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="183" Count="5" />
      <LineId Id="60" Count="0" />
    </LineIds>
    <LineIds Name="FB_MarkDetection.strMark">
      <LineId Id="25" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>